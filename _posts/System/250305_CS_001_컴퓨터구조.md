---
title: "컴퓨터구조"
escerpt: "컴퓨터구조"

categories:
  - System
tags:
  - [System]

toc: true
toc_sticky: true

breadcrumbs: true

date: 2025-03-05
last_modified_at: 2025-03-05

comments: true
 

---


## 1. 컴퓨터 구조 거시적으로 보기

#### 1-1. 컴퓨터 구조의 정의

모든 프로그램은 컴퓨터 부품이 실행하며 **성능 & 용량 & 비용**을 고려해야 한다.

#### 1-2. 컴퓨터 구조의 특징

모든 소스코드와 프로그램은 명령어와 데이터로 변환되서 실행된다.
또한, 컴퓨터 구조는 컴퓨터 부품을 학습하는 과목이다.

1. 프로그램을 이루는 두 정보 : 0 과 1로 이루어진 정보
    - 1) 명령어(instruction) : 컴퓨터를 동작시키는 실질적인 정보
    - 2) 데이터(data) : 명령어의 대상(재료)
 
2. 컴퓨터의 4가지 핵심부품
    - 1) CPU : 명령어 해석, 실행 담당하는 장치

        - 컴퓨터의 **두뇌** 역할
        - 주된역할은 **명령어를 처리** 하는것. CPU는 메모리에서 명령어를 가져와 해석(fetch,인출)하고, 그 명령을 실행(execute)한다.
        
        - register set : CPU 내부에 있는 작은 임시 저장장치(여러개가 존재함)
        - ALU : 계산기 회로
        - 제어장치 : 명령어를 실제로 해석해주는 장치, 제어신호(control signal)을 내보내 주는 장치 
        > 제어신호 : 컴퓨터 부품에게 어떤 작업을 수행할지 알려주는 전기신호  
            - ex) write 1 : 제어신호가 메모리에게 write 1이란 신호를 주면 메모리는 1이란 걸 메모리에 쓰고,저장하는걸 알수있게 된다. 이러한 신호를 주는게 제어신호이다.
        
    - 2) 메인메모리 & 캐시 메모리 : **`실행 중인` 프로그램(=process)** 이나 데이터를 임시로 저장하는 장치(전원커지면 삭제됨)

        - 캐시메모리 : CPU와 RAM사이에 있는 빠른 접근 속도의 임시 저장장치 

        
        - cpu가 명령어를 갖고와서 해석하고 실행할 때 필요한 데이터와 명령어는 메인메모리에 저장된다.캐시메모리이다.
        
        - 메인메모리는 보조기억장치로부터 실행 할 프로그램을 가져온다.

        > address : 메인메모리에 접근하고자 할때 위치정보가 필요하다.

    - 3) 보조기억장치 : `보관할` 프로그램 저장하는 장치 (전원이 꺼져도 저장유지)
    - 4) 입출력장치 : 컴퓨터 내외부와 정보를 주고받는 장치

    - 5) 메인보드(마더보드) : 핵심 부품을 연결할 기판

    - 6) (시스템)버스 : 부품 간 정보를 주고받을 통로


## 2. 명령어

개발자가 작성한 소스코드가 어떻게 명령어로 변환되서 실행되는지 확인해보기.

컴퓨터는 소스코드를 곧장 이해할수 있을까? (java, C/C++, Python, JavaScript,..)

아니다. 컴퓨터는 소스코드를 실행하기전 명령어(+데이터)로 변환되어 실행된다.

즉, **고급언어**로 작성된 소스코드는 내부적으로 **저급언어**로 구성된 명령어와 데이터로 변환된다.

> 소스코드(고급언어) : 사람(개발자)가 이해하기 편한 언어 <br>
  명령어와 데이터(저급언어) : 컴퓨터가 이해하기 편한 언어

### 2-1. 저급언어

1) 기계어 (machine code) :  컴퓨터가 직접 이해하는 근원어다.(0과1로 표현됨)

2) 어셈블리어 (assembly language) : 기계어를 사람이 조금이나마 이해하기 쉽게 만든 언어

<img width="325" alt="Image" src="https://github.com/user-attachments/assets/f3a84d42-845e-46d6-b713-a93f753daef2" />

#### 2-1-2. 저급언어 특징

cpu, compiler등의 종류에 따라서 기계어,어셈블리어가 달라질수 있다.

CPU에 따라서 명령어의 생김새 즉, 기계어의 생김새가 달라질수 있다.

### 2-2. 고급언어에서 저급언어로 변환되는 대표적 방식

1) 컴파일


: 소스 코드 전체가 컴파일러에 의해 검사되고, 목적코드(object code)로 변환된다.

<img width="430" alt="Image" src="https://github.com/user-attachments/assets/7ee3c4b1-426f-4c74-925d-a43967136cdf" />


> 목적코드(object code)란? 
>> 컴퓨터가 이해할 수 있는 0과 1로 이루어진 코드.

> 컴파일에 사용되는언어는? 
>> C/C++, Rust

> 컴파일의 종류는? 
>> gcc, clang, Visual Studio, ...

2) 인터프리트

: 소스 코드 한줄씩 인터프리터에 의해 검사되고, 목적코드로 변환된다.

> 인터프리터에 사용되는 언어는? <br>
>> Python, JavaScript

> Q) 컴파일 vs 인터프리트 비교

| 비교교 | 컴파일 vs 인터프리트 |
| --- | --- |
| 속도 | 컴파일 된 상태면, 컴파일 승! <br> 인터프리트는 한줄씩 검사하기에 느리다.|
| 에러 | 에러발생시 컴파일에 에러있다면 전체적으로 컴파일 에러가 발생한다. <br> 인터프리트는 한줄씩 검사하고 실행되기에 n-1번에서 stop한다. |

* 오개념 주의
  - 소스 코드가 저급 언어로 변환되는 대표적인 방식일 뿐, 컴파일 방식과 인터프리트 방식은 칼로 자르듯 구분되는 개념이 아니다.

  - 컴파일 언어의 특성과 인터프리트 언어의 특성을 모두 갖춘 언어도 있다. ex.JAVA, Python


### 2-3. 명령어 동작 이해하기

[godbolt.org](https://godbolt.org/)

소스코드가 실제 명령어가 되는 process를 check해보기

소스가 어떻게 명령어화 되는지 직접관찰할수 있다.

<img width="719" alt="Image" src="https://github.com/user-attachments/assets/76f3d4d1-f054-43a9-85e9-2406d8465f46" />

  - C언어로 넣으면 오른쪽에 어셈블리어가 나오게 된다.
  - 같은 소스코드라도 CPU의 종류에 따라서 or 컴파일러의 종류에 따라서 변환되는 명령어의 결과가 달라지게 된다.
    
  1. x86-64 gcc 13.2 : 인텔 CPU, AMD CPU로 된 명령어를 해석하는 방법중에 하나이다. 즉, 이런것은 CPU가 명령어를 해석하는 종류라고 인지하면 된다.
    - gcc : 컴파일러의 종류이다. 즉, gcc라는 컴파일러이고, version은 13.2이다. 즉, 컴파일러의 종류, 버전,  CPU의 종류에 따라서 명령어가 달라질수 있다
  2. push, move, sub등은 명령 코드
  3. 그옆에 rbp등은 명령어의 대상이다.(`register이름`을 말한다)
    - `DWORD PTR[rbp-8]`에 저장되어 있는 값을 `eax` register에 mov해라 라는 의미이다.

#### 2-3-1. 실습예시 코드

<img width="505" alt="Image" src="https://github.com/user-attachments/assets/5946ee71-90bb-4804-9b7c-b09138a5651f" />


```C
## 1번
cat hello.c
int main()
{
  printf("hello world\n");
  return 0;
}

## 2번
gcc --version

## 3번
gcc -o hello hello.c 

## 4번
./hello

```

  - 3번 ) gcc를 이용해서 컴파일러 할것이다.( = hello.c의 소스코드를 명령어로 변환할것이다. )
   gcc를 이용해서 컴파일할것이고, 그 변환된 값은 hello 파일로 만들고 싶다. 무엇을 컴파일하냐면 hello.c를 컴파일할것이다.
  이러면 hello라는 파일이 만들어진다.

  - 4번 ) hello world가 출력된다.

<img width="326" alt="Image" src="https://github.com/user-attachments/assets/ee5aa2a2-67eb-4ea6-9876-f422d6ed9a03" />

```C
## 1번
gcc -S hello.c -o hello.S

## 2번
cat hello.S
```

  - 1번 ) hello.c 라는 소스코드를 가지고 어셈블리어를 만들것이고, 변환된 결과값으로 hello.S로 저장할것이다.(-o : output의 의미)

  - 2번 ) hello world라고 출력되게 만들어진 명령어가 어셈블리어로 나오게 된다.

### 2-4. 명령어의 구조

<img width="414" alt="Image" src="https://github.com/user-attachments/assets/0b9b96bb-4268-432d-bdf8-23e1ce632167" />

**무엇을 대상(오퍼랜드,operand, 피연산자)** 으로 **무엇을 수행(=연산코드,OP-code)** 하라


1. operand : 대상(데이터)이 직접 명시되기도 하고, **대상의 위치**가 명시되기도 함.
   
> 대상의 위치? <br>
: 레지스터 이름, 메모리 주소를 말한다.(레지스터란 CPU에 있는 작은 임시저장장치)

2. op-code : 오퍼랜드로 수행할 동작


< 실제 컴퓨터를 동작시키는 명령어 형태의 예시 >

<img width="322" alt="Image" src="https://github.com/user-attachments/assets/a3b9fbf0-ac0d-4f17-9cd5-b5cff30dfdd6" />

> CPU마다 오퍼랜드와 op-code 종류는 다를수 있다.

< 오퍼랜드에 따른 구분 >

<img width="406" alt="Image" src="https://github.com/user-attachments/assets/bb8cd39f-6666-4402-a3a7-4a9e0834df92" />

- 오퍼랜드에 따라 나뉜다. 즉, 오퍼랜드 개수는 유동적일수 있다.
- 그러나 오퍼랜드의 개수에 따라서 같은 코드를 실행하는 명령어의 개수가 달라질수 있다.

- 예시
    - ex) X = (A+B) * C

      <img width="392" alt="Image" src="https://github.com/user-attachments/assets/95b6d04f-e178-40f5-a8f6-f7336268c488" />

      - 오퍼랜드가 2개가 있다면 4단계에 걸쳐서 실행이 된다.

      
      <img width="397" alt="Image" src="https://github.com/user-attachments/assets/03363255-071e-401d-840d-07467604b9ce" />

      - 만약 오퍼랜드가 3개가 있다면 2단계에 걸쳐서 실행이 된다.

> 즉, 명령어에 사용되는 오퍼랜드가 몇개인지에 따라서, CPU가 얼마나 복잡한 명령어를 지원하는지에 따라서 명령어의 개수가 달라질수 있다.

- op-code(연산코드)의 종류는 CPU마다 다르지만 공통적인것만 보자.

| - | 연산코드 | 설명 |
| --- | --- | --- |
| 데이터 전송 | MOVE | 레지스터로 데이터를 옮겨라 | 
| 데이터 전송 | STORE | 메모리에 저장해라 |  
| 데이터 전송 | LOAD(FETCH) | 메모리에서 레지스터로 가져와라 | 
| 데이터 전송 | PUSH | 스택 최상단에 데이터를 저장하라 | 
| 데이터 전송 | POP | 스택 최상단의 데이터를 가져와라 |
| 산술/논리 연산 | ADD/SUBTRACT/MULTIPLY/DIVIDE | 덧셈/뺄셈/곱셈/나눗셈을 수행하라 |
| 산술/논리 연산 | INCREMENT/DECREMENT | 1 증가/감소 시켜라 |
| 산술/논리 연산 | AND/OR/NOT | AND/OR/NOT 연산을 수행하라 |
| 산술/논리 연산 | COMPARE | 두 숫자 또는 TRUE/FALSE값을 비교하라 |
| 제어 흐름 변경 | JUMP | 특정 주소로 실행 순서를 옮겨라 |
| 제어 흐름 변경 | CONDITIONAL JUMP | 조건에 부합할 경우 특정 주소로 실행 순서를 옮겨라 |
| 제어 흐름 변경 | HALT | 프로그램 실행을 멈춰라 |
| 제어 흐름 변경 | CALL | 되돌아올 주소를 저장한 채 특정 주소로 실행 순서를 옮겨라 |
| 제어 흐름 변경 | RETURN | CALL 호출 시 지정했던 주소로 돌아가라 |
| 입출력 제어 | READ(INPUT) | 특정 입출력장치로부터 데이터를 읽어라 |
| 입출력 제어 | WRITE(OUTPUT) | 특정 입출력장치로 데이터를 써라 |
| 입출력 제어 | START IO | 입출력장치를 시작하라 |
| 입출력 제어 | TEST IO | 특정 입출력장치로부터 데이터를 읽어라 |  

CPU는 메모리에 있는 명령어를 하나씩 순차대로 가져와서 실행한다. 


### 2-5. 주소지정

명령어의 연산코드의 대상이 되는 데이터에 찾아가는 방법.

주소지정이란 유효주소를 찾는방법이며, CPU마다 차이가 있다.

> 왜 데이터를 직접 명시하지 않고 위치를 명시할까?  <br>
명령어의 길이가 한정되어 있기 때문.(오퍼랜드는 여러개 올수 있다.)

<img width="260" alt="Image" src="https://github.com/user-attachments/assets/ad9e7edc-f505-4639-8e1a-c87491adefb3" />

> 유효주소 <br> 
: 연산 코드에 사용할 데이터가 저장된 위치, 즉 연산의 대상이 되는 데이터가 저장된 위치

#### 주소지정 방식

1. 즉시 주소 지정

  - 연산에 사용할 데이터를 오퍼랜드 필드에 직접 명시

  - 가장 빠른 주소 지정 + 데이터 크기에 제한

2. 직접 주소 지정

  - 오퍼랜드 필드에 유효 주소(연산에 사용될 데이터가 저장된 메모리 주소) 명시

  - 오퍼랜드 필드로 표현 가능한 메모리 주소 크기에 제한

> CPU가 레지스터에 접근하는 속도 > CPU가 메모리에 접근하는 속도

3. 간접 주소 지정

<img width="448" alt="Image" src="https://github.com/user-attachments/assets/85151806-387d-431e-9742-9a2288f67bf9" />

  - 오퍼렌드 필드에 유효 주소의 주소 명시

  - 유효 주소 크기에 제한은 없으나, 속도가 비교적 느림

> 직접 주소 지정은 메모리에 1번 접근. 간접 주소 지정은 메모리에 최소 2번 접근(CPU입장에서 접근횟수를 생각하면 된다.)

4. 레지스터 주소 지정

<img width="418" alt="Image" src="https://github.com/user-attachments/assets/1e001479-913d-45d2-b673-e86eb7329b6a" />

  - 연산에 사용할 데이터를 저장한 레지스터(레지스터 이름 or 레지스터 주소)를 오퍼랜드 필드에 직접 명시

  - 레지스터 접근은 메모리보다 빠르다!(레지스터 자체가 CPU내에 있기 때문)

5. 레지스터 간접 주소 지정

<img width="483" alt="Image" src="https://github.com/user-attachments/assets/f4c13776-ab84-49be-a80e-8cd969562f6d" />

  - 연산에 사용할 데이터를 메모리에 저장하고, 그 주소(유효 주소)를 저장한 레지스터를 오퍼랜드 필드에 명시

  - 메모리 접근은 한번뿐이다.

> 메모리 접근보다 레지스터 접근으로 처리하는게 일반적인 방법이다.


## 3. 데이터

컴퓨터는 0과 1만을 이해한다. 

| Question | solution | 
| --- | --- | 
| 모든 **양수** 를 0과 1로 표현하는 방법? | 이진수 | 
| 모든 **음수** 를 0과 1로 표현하는 방법? | 2의 보수 | 
| 모든 **소수(or 분수)** 를 0과 1로 표현하는 방법? | 부동소수점 |
| 모든 **문자** 를 0과 1로 표현하는 방법? | 문자집합 & 인코딩 | 


> 문자집합 ? <br> 
: 컴퓨터가 이해할수 있는 문자들의 모음.

> 인코딩 ? <br> 
: 문자집합을 이용해서 컴퓨터가 이해할수 있도록 0과1로 변환하는 과정


### 3-1. 이진법(이진수, binary)의 정의

이진법 : 0과 1로 모든 수를 표기하는 방법

이진수 : 0과 1만으로 표현되는 수

### 3-1-1. 이진법의 특징

| 단점 | solution | 
| --- | --- | 
| 숫자가 너무 길어진다 | 16진법을 활용 | 

> 16진법? <br>
: 1~9와 A~F로 모든 수를 표기하는 방법 (15에서 16올라갈때 자리올림하면 된다.)


| 16진법 | 십진법 |
| --- | --- |
| 0 | 0 |
| 1 | 1 |
| 9 | 9 |
| A | 10 |
| B | 11 |
| C | 12 |
| D | 13 |
| E | 14 |
| F | 15 |
| 10 | 16 |
| 11 | 17 |

<img width="543" alt="Image" src="https://github.com/user-attachments/assets/3957a51d-16ff-4079-bc4f-9f4dc916938c" />

> 16진수를 쓰는 이유 ? 
: 2진수와 16진수의 변환이 편하기 때문이다.


### 3-2. 2의 보수법 (2's complement)

0 과 1만으로 음수를 표현하는 방법 중 하나


### 3-2-1. 2의 보수법 수학적 정의 : 어떤 수 n을 그보다 큰 2^n에서 뺀 값

ex) 11(2) 의 보수는?

  - 11(2) 보다 큰 수는 100(2) 이고, <br>
  100(2) - 11(2) = 01(2) 이다. 

> 실제 계산법 <br>
: 모든 0과 1을 뒤집은 뒤, 1을 더한 값.

* 모든 0과 1을 뒤집은 수 = 1의 보수라고 한다. 즉, 1의 보수에 1을 더한값이 2의 보수이다.

<img width="386" alt="Image" src="https://github.com/user-attachments/assets/e7c9d256-07f8-430a-b17c-1441669e7e34" />

### 3-2-2. 2의 보수법을 사용하는 이유?

: 십진수는 그냥 숫자에 -(마이너스)를 붙이면 음수표현이 가능하다. 그러나, 컴퓨터 내부에선 0과 1만을 이용하기 때문에 음수를 표현할수 없다. 그래서 2의 보수를 사용하는것이다.

실제 2의 보수가 음수 역할을 하는지 확인해보자.

  - 십진수 
    - A -> -A -> - (-A) -> A 

    - 음수 취한후, 한번더 음수 하면 자기자신이 나온다.

  - 이진수 
    - 1011(2) -> 0101(2) -> 1011(2) 
    
    - 1011을 2의 보수 취하고, 한번더 2의 보수 취하면 자기자신이 나온다.

> 어떻게 0과 1만으로 음수를 표현시, 숫자 하나만 보고 컴퓨터는 양수와 음수를 구분할 수 있는가? <br>
  - ex) 1011(2) = 11이란 숫자이다. 이를 2의 보수 취하면 0101(2) = 5 인데, 우리가 원하는 값은 -11 이다. 즉, 구분이 어렵다.

  - solution)
    - CPU 내부에 flag register가 있다. 이게 1일때는 해당 숫자를 음수로 간주한다. 

    - flag register가 음수 플래그로 세팅(숫자 1)되어있다면 음수 / 세팅되어 있지 않다면 양수로 판단

> flag register ? <br>
: CPU 가 명령어를 실행하는 과정에서 참고할 정보의 모음.

### 3-3. 부동소수점(floating point)

컴퓨터 내의 소수점 표현 방식의 한계가 존재함. 즉, 부동 소수점의 한계가 존재함.

우리는 십진수를 기반으로 사용한다. 부동소수점을 이진수를 소수점으로 표현하기 위해선, 십진수 기반의 소수를 정확하게 표현하기가 어려운 경우가 있다.

> 지수(exponent)

> 가수(significand)

ex) 123.123십진수를 m X 10^n꼴로 나타낸다고 가정해보면,

  가수 지수(승을 지수라고 표현)
  1.23123 X 10^2
  1231.23 X 10^-1

컴퓨터 내부의 소수 표현방식(부동 소수점 표현방식, IEEE 754)

이진수를 m X 2^n 꼴로 나타내고, 가수 부분은 1.XXX 꼴을 띄고 있음.
(어차피 가수부분은 1.XXX형태이므로, XXX부분(소수부분)만 저장하면 됨.)

지수부분인 n은 bias값이 더해져 저장됨. 바이어스 값은 2^(k-1)-1 (k는 지수의 비트 수) 왜냐하면 음수가 나올수도 있잖아.
예를 들어 지수비트에 8bit가 사용되었다면 바이어스값은 2^7 -1 이다.
만약 부호비트가 세팅되어 있다면 음수고, 그렇지 않다면 양수다.
<img width="701" alt="Image" src="https://github.com/user-attachments/assets/55119ca7-4e44-43fb-902a-a9b6175f2657" />

이와 같은 표현의 문제점.
  - 십진수 소수를 이진수로 표현할 때 십진수 소수와 이진수 소수 표현이 딱 맞아 떨어지지 않을 수 있다.
  - ex) 1/3이라는 분수 m X 3^n 꼴로 표현하면 딱 떨어진다. n에 -1 이라고 지정하면 되잖아.
  - ex) 1/3이라는 분수 m X 10^n 꼴(십진수 형태)로 표현하면 무한히 많은 가수가 필요하다. 0.33333....먼가 딱 떨어 지지않는다.

  - ex) 1/10이라는 분수 m X 10^n 꼴로 표현하면 딱 떨어진다. 1x 10^-1이면 된다.
  - ex) 1/10이라는 분수 m X 2^n 꼴로 표현하면 무한히 많은 가수가 필요하다.

컴퓨터에서는 가수로 저장할수 있는 부분이 한정되어 있다. 그래서 실제로 무한히 많은 가수가 필요한 경우에는, 일부 가수를 버릴수 밖에 없다. 그래서 오차가 발생할수 밖에 없다.

### 3-4. 문자 인코딩과 디코딩 정의

0과 1로 문자 표현하기

  <img width="505" alt="Image" src="https://github.com/user-attachments/assets/b9715c22-f699-497e-a45f-6a9e21a6cd7a" />

    - 문자 집합(character set) : 표현 가능한 문자들의 집합

    - 문자 인코딩 : 문자를 0과 1로 이루어진 문자 코드로 변환

    - 문자 디코딩 : 0과 1로 이루어진 문자 코드를 문자로 변환

#### 3-4-1. 문자가 깨진다면?

- 원인 
  - 컴퓨터가 이해할수 없는 문자집합을 사용하거나, 호환되지 않은 인코딩 방식으로 데이터를 읽어들였거나, A라는 방식으로 인코딩했는데 B라는 방식으로 디코딩한 경우

- 해결책 
  - 인코딩방식 확인후, 동일한 방식으로 디코딩 하면 해결된다.

#### 3-4-2. 대표적인 인코딩&디코딩방식

1. 아스키 코드(ASCII)
    
    - 아스키 문자 집합 : 초창기 문자 집합

      <img width="457" alt="Image" src="https://github.com/user-attachments/assets/c411a246-4f9b-40f3-9cdb-579b570a953c" />

    
      - 알파벳 + 아라비아 숫자 + 일부 특수 문자 + 제어 문자

      - 0 부터 127까지의 숫자에 알파벳, 아라비아숫자, 일부 특수문자,제어문자 등이 대응되어 있다.

      - ASCII 코드는 기본적으로 8bit를 이용해서 표현한다. 이중 하나는 오류검출에 이용하기 때문에 실제로는 문자표현에는 7bit를 사용한다.그래서 2^7 = 128 이 나온다.

      - 소문자 a는 십진수 97로 인코딩됨을 알수 있다. 즉, **대응되는게  인코딩방식**임을 알수 있다.

      ![Image](https://github.com/user-attachments/assets/ffb80d66-9cca-4960-8d16-825626e2dce8)

      ```C
      $ cat ascii.c

      #include <stdio.h>
      int main()
      {
        printf("%d \n", 'a'); ## 정수로 인식해서 출력함
        printf("%c \n", 97);  ## 문자로 인식해서 출력함

        return 0;
      }

      $ gcc -o ascii ascii.c
      $ ./ascii
      97
      a
      ```

2. 유니코드 문자 집합 

[About UNICODE 란?](home.unicode.org)

[유니코드에 부여된 코드포인트 확이 가능 사이트](codepoints.net)

> ASCII문자 집합의 문제점? <br><br>
한글/다양한 언어 표현이 안된다. <br> 왜냐하면 7bit로 문자를 표현하려고 하다보니 한계 존재. <br> ASCII코드의 문자집합을 인코딩하는 방식은 **대응** 방식 밖에 없다. <br> 그러나, 유니코드는 같은 문자 집합 일지라도 인코딩하는 방식이 다양한다.


 
- 대부분의 언어 + 특수문자 + 이모티콘 + 화살표 등 으로 이루어짐.

구조형태

  - U + XXXX 
    - U는 unicode에서 16진수임을 나타내기 위함임. 
    - XXXX에는 4자리의 16진수가 부여되어 있음. <br> 이를 **코드 포인트(유니코드 문자에 부여된 고유한 수)** 라고 부른다.

    - ex) '한' 이라는 글자에 부여되어 있는 코드 포인트는 D55C(16) 으로 되어 있다.

    - **즉, 인코딩 대상은 코드포인트 이다.**
"유니코드 문자에 부여된 고유한 수"인 코드 포인트를 어떻게 인코딩하는지에 따라서 유니코드 인코딩 방식이 달라진다.(utf-8, utf-16, utf-32 등으로 나뉨) 즉, 유니코드 문자 집합을 인코딩 하는 다양한 방법들이 있음.

![Image](https://github.com/user-attachments/assets/2b7ea462-5753-4f35-9d30-57aaf0c998ab)

```python
import unicodedata

input_value = input("인코딩할 값을 입력하세요: ")

print("유니코드 코드 포인트:")
for char in input_value:
    code_point = ord(char)
    print(f"문자 '{char}': U+{code_point:04X}")

# UTF-8 인코딩
utf8_encoded = input_value.encode('utf-8')
print("UTF-8 인코딩 결과:", utf8_encoded)

# UTF-16 인코딩
utf16_encoded = input_value.encode('utf-16')
print("UTF-16 인코딩 결과:", utf16_encoded)

# UTF-32 인코딩
utf32_encoded = input_value.encode('utf-32')
print("UTF-32 인코딩 결과:", utf32_encoded)
```

## 4.CPU 구성요소

ALU(산술논리연산장치), 제어장치,  **레지스터(들)** 이 있다.

### 4-1. ALU(산술논리연산장치)
: 연산을 수행하는 장치(계산을 담당하는 회로)

<img width="433" alt="Image" src="https://github.com/user-attachments/assets/5fb7aa8b-658e-47ce-9dad-27ea9383d9b5" />

  - 레지스터로부터 피연산자(연산의 대상)을 받아들이고

  - 제어 장치로부터 제어 신호(연산할 작업)를 받아들인다.

  - 연산의 결과를 레지스터, 플래그 레지스터에 저장한다.

  - 즉, 연산 전,후로 모든 값들이 레지스터에 담긴다. 그래서 레지스터를 잘 관찰하면 row level을 관찰 및 분석할수 있다.

> 플래그 레지스터 <br>
: 연산의 결과에 대한 부가 정보
  <img width="494" alt="Image" src="https://github.com/user-attachments/assets/3efebdc8-ea83-4cba-a11f-c00335b12b03" />

  | 플래그 | 정의 |
  | --- | --- |
  | 부호 플래그 | 연산한 결과의 부호를 나타낸다 |
  | 제로 플래그 | 연산 결과가 0인지 여부를 나타낸다 |
  | 캐리 플래그 | 연산 결과 올림수나 빌림수가 발생했는지 여부를 나타낸다 |
  | 오버플로우 플래그 | 오버플로우가 발생했는지 여부를 나타낸다 |
  | 인터럽트 플래그 | 인터럽트가 가능한지 여부를 나타낸다 |
  | 슈퍼바이저 플래그 | 커널 모드로 실행 중인지, 사용자 모드로 실행 중인지를 나타낸다 |


> 인터럽트 ? <br>
: CPU의 정상적인 흐름을 끊는 신호 <br>

> 운영체제 ? <br>
: 프로그램을 말한다. 운영체제 중에서도 가장 특별한 부분이 **커널**이다. 핵심적인 업무, 즉 엔진역할을 하는게 커널이다.


### 4-2. 제어장치
: 명령어를 해석하고 제어 신호를 내보내는 장치

<img width="532" alt="Image" src="https://github.com/user-attachments/assets/834d3d23-7ac1-498f-9b54-9eeb0334da0a" />


> 제어신호 <br>
: 컴퓨터 부품들에게 어떤 동작을 하는지 알려주는 전기신호이다.

> 시스템 버스란? <br>
: 각 컴퓨터의 부품들이 서로 정보들을 주고받을수 있는 통로이다.(= 척추 같은 역할) <br>
데이터 버스 + 주소버스 + 제어버스 3가지 종류로 세스템버스는 구성되어 있다.

이중 제어버스를 이용해서 제어신호가 전달이 된다.
 
> 클럭신호 <br>
<img width="432" alt="Image" src="https://github.com/user-attachments/assets/a2303919-b572-4291-bce4-f1c9fef20393" /> <br>
부품을 일사분란하게 움직일 수 있게 하는 시간 단위, <br>
부품이 움직이는 박자


### 4-3. **레지스터(들)**
: 명령어 처리 전후로 값을 임시 저장하는 장치

<img width="442" alt="Image" src="https://github.com/user-attachments/assets/397c0339-4795-4188-b505-62297c264874" />

  - CPU마다 레지스터들의 이름, 갯수, 주소지정의 방식, 용량등이 달라질수 있다.

  - 프로그램의 실행 전후로 값을 임시 저장하는 작은 저장장치

  - 레지스터에 어떤 값이 저장되는지만 관찰해도 프로그램의 low level의 흐름을 볼 수 있다.

  - CPU마다 레지스터의 이름, 크기, 종류가 다양하다.

  - 레지스터 관찰하는 방법은 `디버거`로 관찰할수 있다.
 
#### 4-3-1.레지스터 종류?

1. **프로그램 카운터** <br>
: 메모리에서 가져올 명령어 주소(메모리에서 읽어들일 주소)

  <img width="494" alt="Image" src="https://github.com/user-attachments/assets/34be5659-7c8f-413d-ac2d-ec3240052d1a" />

    - 프로그램 카운터는 일반적으로 1씩 증가되며 메모리의 프로그램이 순차적으로 실행된다.

    - 일반적이 아닌경우는 ?
      - 분기(JUMP)
      - 인터럽트


2. 명령어 레지스터 <br> 
: 해석할 명령어 (메모리에서 읽어들인 주소)

    - 명령어 제지스터를 제어장치가 해석한다.

3. 메모리 주소 레지스터 <br>
: 메모리의 주소 (읽어들일 주소 값)

4. 메모리 버퍼 레지스터<br> 
: 메모리와 주고받을 명령어와 데이터

    - 시스템버스는 주소버스, 데이터버스,제어버스  이렇게 3개로 구성되어 있는데 명령어와 데이터가 데이터버스를 이용해서 주고받을 수 있다. 즉, 데이터버스를 통해서 주고받은 값이 메모리 버퍼 레지스터에 저장되는 거다. 시스템 버스의 주소버스를 가지고 주고 받은 값은 메모리 주소 레지스터에 저장된다.

5. 플래그 레지스터 <br>
: 연산 결과에 대한 부가 정보 저장

6. 범용 레지스터 <br>
: 범용적으로 사용 가능한 레지스터 (여러개 있음)

7. 스택 포인터 <br>
: 스택 주소 지정 방식에서 사용되는, '스택의 꼭대기'를 가리키는 레지스터

8. 베이스 레지스터 <br> 
: 변위 주소 지정 방식에서 사용되는, '떨어진 거리'를 가리키는 레지스터

#### 4-3-2. 메모리 내의 스택

<img width="462" alt="Image" src="https://github.com/user-attachments/assets/2e6fb93b-25de-4be3-b243-527917e8dc2f" />

1. 변위 주소 지정 방식 <br>
: 오퍼랜드 필드의 값을 변위 삼아, 특정 레지스터 값을 더해 유효 주소를 얻는 주소 지정

  <img width="415" alt="Image" src="https://github.com/user-attachments/assets/ebec2861-1a66-43a7-affb-e6fc448ba334" />

2. 상대 주소 지정 <br>
: 오퍼랜드 + 프로그램 카운터 == 유효주소

  <img width="410" alt="Image" src="https://github.com/user-attachments/assets/88ee6cd4-3506-4190-ac1b-29fceff5c6ef" />

    - 다음에 실행할 명령어의 이전 -3단계의 명령어를 실행하게 된다.

3. 베이스 레지스터 주소 지정 <br>
: 오퍼랜드 + 베이스 레지스터(기준주소) == 유효주소

  <img width="424" alt="Image" src="https://github.com/user-attachments/assets/7e9d8b7f-e5f9-46e0-906a-b7b37c4d39e3" />

    - 기준주소로 부터 얼마만큼 떨어진 주소를 실행하게 된다.

#### 4-3-3. 레지스터 살펴보기

x86-64에서 사용되는 대표적인 assembly자료이다.

push    rbp
mov     rbp, rsp
sub     rsp, 16
mov     DWORD PTR [rbp-4], 1
mov     DWORD PTR [rbp-8], 2
mov     edx, DWORD PTR [rbp-4]
mov     eax, DWORD PTR [rbp-8]
add     eax, edx
mov     DWORD PTR [rbp-12], eax
mov     eax, DWORD PTR [rbp-12]
mov     esi, eax
mov     edi, OFFSET FLAT:.LC0
mov     eax, 0
call    printf
mov     eax, 0
leave
ret

rbp라는 함수를 push하고, rsp에 있는 값을 move시키고, rsp에 있는 값에 16byte의 공간을 할당한다. 여기서 16byte공간은 변수들을 위한 공간인거다.
DWORD PTR [rbp-4], 1 : Double word(word의 2배를 의미, word란 cpu가 받아들이고 처리할수있는 명령어의 단위를 의미) pointer(주소를 가르키는애), 즉 rbp에서 4만큼을 뺀 주소를 가르킨다. rbp에서 4만큼 뺀 공간을 가르키고 그곳에 1을 저장한다는 의미.
edx, DWORD PTR [rbp-4] : rbp-4 공간에 저장한걸 edx 레지스터에 담는다. edx는 문서를 보면 32bit임을 알수 있다.

mov     eax, DWORD PTR [rbp-12]
mov     esi, eax
mov     edi, OFFSET FLAT:.LC0
mov     eax, 0
call    printf
: 데이터값(DWORD PT [rbp-12])를 eax에 로드를 하고, eax에 있는값을 프린트의 인자로 넣기 위해 esi라는 곳에 담아둔다. 두번째 인자로서 print할 대상(OFFSET FLAT:.LC0)을 지정하고,  그걸 edi라는 곳에 넣어둔다. 그리고 최종적으로 printf라는 function을 호출하게 된다.
그리고 leave와 return함수를 통해 해당 main함수가 끝나게 된다.

### 4-4 명령어 사이클과 인터럽트

CPU가 메모리에 있는 명령어를 갖고와서 실행할때는, 일정한 주기를 갖고와서 실행한다. 즉 정형화된 흐름이 있다. 그 일정한 흐름을 명령어 사이클이라고 한다.

일정한 주기를 바탕으로 CPU는 규칙적인 `클럭` 신호에 맞춰서 명령어를 인출하고 실행하는걸 반복한다. 그 흐름을 끊는 특별한 상황이 인터럽트이다.


CPU가 명령어를 순차적으로 처리하는 양상 
  - 명령어 사이클 : CUP가 명령어를 처리하는 정형화된 주기, 흐름

  step1) 메모리에서 명령어를 가져오고(=인출하고=Fecth)  = 인출사이클
  step2) 가져온 명령어를 실행하고(=execute),          = 실행사이클
  step1,2를 계속 반복한다.

  - 실제 연산에 사용될 데이터를 얻기 위해 한번 더 메모리에 접근해야 할 경우가 있다.
  - 명령어를 인출했더라도 바로 실행이 불가능하다면 ? (간접주소지정 방식인 경우) => 간접사이클 추가하여 해결.

    <img width="232" alt="Image" src="https://github.com/user-attachments/assets/2292a27d-b26a-43a6-909a-029a17b31e0b" />

#### 4-4-1. 인터럽트
interrupt : 방해하다, 중단시키다.
CPU의 정상적인 실행 흐름을 방해하는 신호

exception, fault도 interrupt의 일종이다.

입출력장치에게 입출력 작업을 맡겨두면, CPU는 인터럽트를 받을 때까지는 다른 업무 수행 가능.

인터럽트의 종류?
  동기 인터럽트, 비동기 인터럽트가 있다.(intel 공식문서 참고하여 분류함)

동기 인터럽트 (예외, Exception)
  - 주로 CPU에 의해 발생
  - 명령어 처리 도중 비정상적인 상황에 마주했을 경우 발생

비동기 인터럽트 (하드웨어 인터럽트)
  - 주로 입출력 장치에 의해 발생
  - 세탁기 완료 알림, 전자레인지 조리 완료 알림과 같은 '알림' 역할 수행
  - CPU는 주기적으로 완료 여부를 확인해주는데 이를 **pooling**이라 한다. 이렇게 pooling을 하게 되면 불필요한 CPU사이클이 소비되게 된다. 그래서 명령어를 효율적으로 처리하기 위해서 완료 알림이 오기전까지 사이클 낭비없이 내 업무에 집중하겠다.라는 취지로 하드웨어 인터럽트가 활용된다.


**인터럽트 처리 순서**
1. 입출력 장치는 CPU에게 **인터럽트 요청 신호**를 보냄.
2. CPU는 실행 사이클 이후 인출 전 인터럽트 여부 확인
3. CPU는 인터럽트 요청 확인 후, 인터럽트 플래그를 통해 인터럽트 수용 여부 확인
  - 플래그 레지스터 안에 인터럽트 플래그를 이용.
4. 인터럽트가 가능하다면 지금까지의 작업 백업
  - 백업은 메모리의 stack에다가 한다. 메모리에는 stack처럼 활용할 공간이 정해져 있다.
5. **인터럽트 벡터**를 참고하면 **인터럽트 서비스 루틴**(인터럽트 핸들러 실행)
  - 인터럽트 벡터? 인터럽트의 시작주소가 명시되어 있는곳.
  - 인터럽트 서비스 루틴? 해당 인터럽트를 처리하기 위한 특별한 프로그램.
  - 즉 프로그램이므로, 명령어와 데이터로 이루어짐.
6. 인터럽트 서비스 루틴 실행 후 백업한 작업 복구, 실행 재개
  - memory의 stack에다가 백업을 한다. 백업한 정보에는 PC가 있다. 이걸 복구한후, 실행재개 한다.

인터럽트
- 인터럽트 요청 신호 : CPU 작업을 방해하는 인터럽트에 대한 요청
- 인터럽트 벡터 : 인터럽트 서비스 루틴의 시작 주소를 포함하는 인터럽트 서비스 루틴의 식별정보
- 인터럽트 서비스 루틴 : 인터럽트를 처리하는 프로그램

<img width="167" alt="Image" src="https://github.com/user-attachments/assets/048a3e87-a460-47c2-936d-3df0693107f3" />

  - PC값은 인터럽트가 발생하기 전까지는 1씩 계속 증가하면서, 순차적으로 프로그램을 실행한다.
  - 만약 중간에 인터럽트가 발생하면, 인터럽트가 가능한지 살펴보고, 인터럽트 발생여부와 수용여부를 확인해보고, 만약 둘다 가능하다면
  - 인터럽트가 어떤 인터럽트인지, 인터럽트 벡터를 참고해서 이 인터럽트를 처리하기 위한 인터럽트 서비스 루틴의 시작주소는 어디인지, 그렇게 알아낸 인터럽트 벡터를 통해서 알아낸 시작주소로 점프하게 된다. 해당 인터럽트 서비스 루틴A가 끝났다면, 다시 실행한곳으로 돌아가서 재개가 된다. 

<img width="302" alt="Image" src="https://github.com/user-attachments/assets/93b88c96-7888-4090-9f5a-593d9619312b" />

 - 명령어사이클에 인터럽트 사이클 추가

 결국 CPU는 위 사이클을 반복하면서 실행을 한다.

### 4-5. 멀티 코어와 멀티 프로세서

빠른 CPU를 위한 하드웨어적인 설계에 대해 알아보자.

1. 컴퓨터 부품은 클럭 신호에 맞춰 일사 분란하게 움직인다.

    - 클럭신호를 받아들이는 주체는 CPU의 구성요소중 하나인 제어장치가 받아들인다.

2. CPU, 즉 제어장치가 클럭 신호에 따라 명령어 사이클에 맞춰 명령어들을 실행한다.

클럭 속도가 높은 CPU는 일반적으로 성능이 좋다.

  - 클럭 속도는 일반적으로 CPU의 성능척도의 역할을 한다.

클럭 속도(Hz,헤르츠) : 1초에 반복된 클럭(=주기)의 횟수로 측정
  - 1Hz
  - 10Ghz = 10^9 Hz
 
클럭신호는 동적이다. 그래서 CPU의 제조사의 spec을 보면 기본클럭 =! 최대클럭 이 나온다. 이는, 클럭신호가 일정하지 않음을 보여주며, 최소한 기본클럭보다 떨어지는 경우는 거의 없다.

> CPU 오버클럭킹(Over + Clock) <br>
1.임의로 클럭 속도를 끌어올리는 기술 <br>
2.부팅시 BIOS에서 설정 가능(오늘날에는 UEFI환경으로 바뀜)



<img width="522" alt="Image" src="https://github.com/user-attachments/assets/d7dcda58-3be8-4d53-819c-3c284d221a96" />


그저 무지막지하게 클럭 수를 높이면 성능이 비례하여 상승할까? **(클럭과 발열의 관계)**
  - NO : 클럭 수가 높아질 수록 발열 문제가 심각해지기 때문.

클럭 수를 높이는 방법 이외에 성능을 높일수 있는 방법은? **(코어와 멀티코어)**

  - 코어(core)수 늘리기 -> 멀티 코어 프로세서

> 코어 <br>
: 명령어를 인출하고, 해석하고, 실행하는 CPU 내 부품
  
코어가 여러 개 있다면?  한번에 여러 명령어 인출,해석 실행 가능

<img width="486" alt="Image" src="https://github.com/user-attachments/assets/c91f3e8b-f84f-4985-9371-db6c0136c613" />


코어 수를 늘리는 방법 이외에 성능을 높일 수 있는 방법은? **(스레드와 멀티스레드)**

  - 스레드 수를 늘리기 -> 멀티 스레드 프로세서

#### 4-5-1. thread(스레드)

<img width="536" alt="Image" src="https://github.com/user-attachments/assets/06170506-2e1f-49c1-bf00-381bdeaaf2d0" />

  - 하드웨어적 스레드 : 하나의 코어가 동시에 처리하는 명령어 단위

  - 소프트웨어 스레드 : 하나의 프로그램을 독립적으로 실행하는 단위
  
    - 메모리내에서 동시에 여러 스레드를 실행할수 있음.

  - CPU가 1 스레드라도 여러개의 소프트웨어 스레드를 만들수 있다. 즉, 1스레드의 CPU를 가지고도, 워드프로세스의 여러 프로그램(맞춤법검사, 자동 저장 등)을 동시에 실행시킬수 있다.

  - CPU의 관점에서의 스레드는 하드웨어적 스레드를 말한다. 

  - 멀티 스레드 CPU
    
    - 여러 개의 하드웨어적 스레드로 한 코어로 여러 명령어를 실행 가능한 CPU

      - 복수의 레지스터 세트를 만들어서 사용한다.

> 레지스터 세트 ? <br> <br>
하나의 명령어를 실행하기 위해 꼭 필요한 레지스터 집합 <br><br>
Ex) PC는 다음을 실행할 주소를 가르킨다. 하나의 core에 PC가 1개라면? 다음 실행할 주소를 하나만 가르킬수 있음. 만약 PC가 여러개면? 하나의 core안에서 다음 실행할 주소를 여러개 가르킬수 있다.

Ex) 2core 4 thread 의미

| category | 의미 |
| --- | --- |
| CPU 입장 | 해당 CPU는 동시에 실행할수 있는 명령어는 4개이다. core가 2개있고, 각 core마다 레지스터가 2개씩 있으니깐. |
| 메모리 입장 | 인출되는 명령어,실행되고 있는 명령어, 저장도 한번에 각각 4개씩 되니깐 1core 1thread CPU가 4개 있나?  아니면, 4core 1thread가 1개 있나? 이렇게 착각할수도 있다. 그처럼 메모리 입장에서는 1core 1thread가 몇개있는지를 논리적으로 판단한다.|


메모리 입장(메모리 + 메모리에 저장된 프로그램 입장) 에서 하드웨어 스레드와 코어를 구분할 수 있을까? 
  - NO : 각 하드웨어를 마치 하나의 단일 스레드/코어 프로세서로 인식(1core 1 thread로 인식)

이런 점에서 하드웨어 스레드를 논리 프로세서라고 부르기도 함.

멀티 코어 vs 멀티 스레드 비유로 이해하기
  - 스타크래프트 : 병사를 생산할 수 있는 건물을 짓고, 많은 병사를 뽑아내어 이기는 게임.(병사를 뽑아내는것을 명령어를 처리한다고 생각해보자.)

    - 테란 : 한 번에 하나의 병사만 생산 가능(현재 1core 1thread)

      - 만약 여기서 건물 하나 더지면 2core 2thread가 된다.

    - 저그 : 한번에 세개의 병사 생산 가능(1core 3 thread)

      - 건물이 하나 추가되면 2core 6 thread가 된다.

    - 테란입장에서 저그를 보면 저그가 건물 6개를 가지고 있다고 인식(논리 프로세서) 왜냐하면 테란은 1건물에 1개씩만 처리되니깐. 저그가 동시에 6개가 처리되는걸 보면 6건물이 있음으로 논리적으로 판단한다.

### 4-6. 명령어 병렬처리 - 파이프라이닝


> HW적인 입장에서 CPU의 성능을 높일수 있는 설계 <br>
1. 높은 클럭 수
2. 멀티 코어
3. 멀티 프로세서

SW적인 입장에서 명령어를 효과적으로 처리하는 방법으로는 명령어 병렬 처리 기법이 있다.

그중에 대표적으로 **명령어 파이프라이닝** 이 있다. 이건 명령어를 동시에 처리하는 기법이다. 

> 스레드 : (CPU관점) 하나의 core가 몇개의 명령어를 동시에 실행할수 있는지에 대한 척도
(운영체제, 프로그래밍 과점) 하나의 프로그램이 동시에 실행될 수 있는 단위로 바뀜.

#### 4-6-1. 명령어 파이프라이닝

하나의 명령어가 처리되는 과정을 비슷한 시간 간격으로 나누면?
1. 명령어 인출
2. 명령어 해석
3. 명령어 실행
4. 명령어 저장
* 주요 아이디어 : 위 단계들은 서로 겹치지만 않는다면 한꺼번에 실행할 수 있다.
ex) A명령어도 해석하고, B명령도 해석할순 없다.(CPU의 구성요소가 겹치기 때문에) 하지만 A명령어를 해석할때 B명령어를 실행할수 있다.

<img width="432" alt="Image" src="https://github.com/user-attachments/assets/b9d9edf0-5682-4333-ac78-52972be62f57" />

#### 4-6-2.명령어 파이프라이닝에 실패하는 시나리오 : 파이프라인 위험(pipeline hazard)

명령어를 동시에 실행하기 어려운 상황

1. 데이터 위험(data hazard)
: 명령어 간 의존성에 의해 발생 /  겹쳐 실행하기 어려운 명령어도 있다!
  - 1) 데이터가 쓰여진 직후 그 데이터를 읽어들이는 경우 (RAW, read after write)

  - ex) 
    ```
    명령어 1: R1 <- R2 + R3 // R2 레지스터와 R3 레지스터를 더한 값을 R1에 저장
    명령어 2: R4 <- R1 + R5 // R1 레지스터와 R5 레지스터를 더한 값을 R4에 저장
    ```
      - 위 예를 보았을때 명령어 1을 해석하는 동안에 명령어 2를 인출할수 있는가? 
        - No : 레지스터1 에 해당되는 값이 모두 결정되야 그다음, 명령어2가 실행될수 있기 때문에.

  - 2) 데이터를 쓴 직후 그 데이터에 새 내용을 쓰는 경우(WAW, write after write)

  - ex) 
    ```
    명령어 1: R1 <- R2 + R3 // R2 레지스터와 R3 레지스터를 더한 값을 R1에 저장
    명령어 2: R1 <- R4 + R5 // R4 레지스터와 R5 레지스터를 더한 값을 R1에 저장
    ```
      - 위 예를 보았을때 명령어 1을 해석하는 동안에 명령어 2를 인출할수   있는가? 
        
        - No : 레지스터1 에 해당되는 값이 모두 결정되야 그다음, 명령어2가 저장되야 정확한 값이 R1에 등록이 된다. 만약 명령어2가 저장되고 이후, 명령어1이 저장되면 레지스터1에는 우리가 원했던 명령어2의 값이 최종적으로 저장이 안되었기 때문에 오류가 난다.

        - 위처럼 되면, 즉 파이프라인이 여러개인 경우 잘못된 값이 저장 될수 있다.

  - 3) 데이터를 읽어들인 직후 그 데이터에 새 내용을 쓰는 경우(WAR, write after read)

  - ex) 
    ```
    명령어 1: R3 <- R2 + R1 // R2 레지스터와 R1 레지스터를 더한 값을 R3에 저장
    명령어 2: R1 <- R4 + R5 // R4 레지스터와 R5 레지스터를 더한 값을 R1에 저장
    ```
      - 위 예를 보았을때 명령어 1을 해석하는 동안에 명령어 2를 인출할수   있는가? 
        - No : 레지스터1을 보면 명령어간에 의존성이 있다. 이땐, 예상치 못한 결과를 초래할수 있다.



2. 제어 위험(control hazard)
: 프로그램 카운터의 갑작스러운 변화에 의해 발생 (분기)

<img width="459" alt="Image" src="https://github.com/user-attachments/assets/3dbf7477-9573-4ccb-b966-c8aeb8eb95c8" />

PC는 특별한일이 없는한, 기본적으로 +1씩 순차적으로 진행한다. 그런데 JUMP명령어가 생겼다면, JUMP가 될 그 명령어 주소로 PC값이 업데이트 될것이다. 

  - 10번지 명령어가 JUMP60 번지로 실행이 되어야 한다. 그런데, 11번지,12번지 명령어가 이미 다음 명령어 대해 인출을 해놓았다.  그런데 10번지명령어에서 해석후 실행했더니 60번지로 JUMP를 해야 한다. 즉, 다음번지 11,12번지 명령어를 인출할필요가 없게 됬으니 헛수고가 된것이다.  

  - 위와같은 제어위험을 방지하기 위해서, **분기예측(branch prediction)** 이란 기술이 있다. 미리 분기할 곳을 예측해서 위와같은 헛수고를 줄이는 기술이다.

3. 구조적 위험(structural hazard)
: 서로 다른 명령어가 같은 자원을 사용하려 할 경우 발생

<img width="442" alt="Image" src="https://github.com/user-attachments/assets/c2455408-a59e-4346-a056-8b4d33f76ab1" />

  - 같은 메모리에 저장하려는게 겹칠경우, 같은 ALU를 사용하려는 경우.
  - 이런경우는 CPU설계에 많이 의존적인 경우다. 요즘처럼 HW 스펙이 좋거나, 고성능의 설계가 이뤄진 경우에는 구조적 위험은 대체로 완화되는 경우가 많다.
 
#### 4-6-3. 파이프라이닝의 발전 : 슈퍼스칼라

다수의 명령어 파이프라인을 두는 방식(요즘 현재 컴퓨터 방식이다.)

여러 명렁어 동시 인출/해석/실행/저장이 가능한 CPU

<img width="464" alt="Image" src="https://github.com/user-attachments/assets/618a9c7d-42f4-448a-9e18-f8e4e0948e76" />
 
  - 멀티 코어, 멀티스레드인 방식이다. 

  - 파이프라인의 개수가 많아질수록 명령어 의존도가 높아지고, 파이프라인 hazard를 처리하는게 점점 어려워짐. 그래서 코어가 2개라고 2배 속도가 좋아지거나 이렇게 배수로 늘어나진 않는다. 다만, 이론적으로는 전공책에서는 파이프라인 개수에 비례에서 성능이 증가한다고 쓰여있다.

파이프라이닝을 십분 활용하기 위한 CPU구조

| 구분 | CISC(시스크) | RISC(리스크) |
| --- | --- | --- |
| 의미 | Complex Instruction Set Computer | Reduced Instruction Set Computer |
| 계열 | Intecl x86 CPU | ARM CPU |
| 특징 | 1. 복잡하고 다양한 기능의 명령어 제공 <br> 2.다양한 주소 지정 방식 제공(이것은 자주사용하지 주소지정까지도 많이 제공한다.그런데 CPU가 메모리에 접근하는것은 레지스터에 접근하는것에 비해 압도적으로 느리다. 그래서 CPU의 성능에 최적화하기 위해선,메모리접근에 최소화하고 레지스터를 활용하는게 좋다.) <br> 3. 적은 명령어 수로 명령어 실행 가능 <br> 4. CISC는 명령어 하나하나가 굉장히 다채로운 기능을 제공하기 때문에, 소스코드를 기계어 혹은 어셈블리어로 컴파일 했을때, 명령어 수가 적다. 그래서 메모리 절약할수 있다. 그래서 각광을 받았지만, 현재는 메모리가 커졌기에, 명령어 파이프라인의 중요도가 더 커짐.| 1. 짧고 규격화된 명령어(하나의 명령어를 처리하는데 대부분 1클럭 내외로 실행하도록 설계됨. 1~1.5 CPI로 구성됨) -> 명령어 파이프라이닝에 유리 <br> 2.적은 수의 명령어 제공 <br> 3. 메모리 접근 최소화(레지스터 활용)(메모리 접근을 하는 명령어인 load(갖고오고), store(저장하고) 이렇게 2가지 명령어로만으로 접근하겠다해서 RISC를 load-store구조라고 부르기도 한다.) <br> 4. CISC에 비해 더 많은 명령어로 실행 -> 컴파일러의 역할이 중요(컴파일러가 소스 코드를 기계어로 번역해주는 놈이기 때문에. ) ex) Apple의 M1도 RISC계열이다. | 

| 단점 | 1. 하나의 명령어 실행에 일정하지 않은 클록 수(왜냐하면,명령어 하나하나가 다채롭고, 강력한 기능을 제공하기 때문에 이것들을 처리하는 시간이 일정하지 않다.) -> 명령어 파이프라이닝에 불리(왜냐하면, 인출,해석,실행,저장하는 명령어 파이프라인이 일정해야 공장처럼 잘 돌아가는데 클록수가 다르기에 착착착 돌아가기가 어렵다.) <br> 2. 대부분의 명령어는 사용되지 않는다! <br> 3. "CISC" 명령어 중 20% 정도의 명령어가 전체 명령어의 80%를 차지한다" | - |


| 복잡하고 다양한 명령어 | 단순하고 적은 명령어 |
| 형태와 크기가 다양한 명령어 | 짧고 규격화된 명령어 |
| 다양한 주소 지정 방식 | 메모리 접근을 단순화, 최소화 |
| 프로그램을 이루는 명령어의 수 적음 | 프로그램을 이루는 명령어의 수 많음 |
| 여러 클록을 걸쳐 명령어 수행 | 한 클록 내외로 명령어 수행 |
| 파이프라이닝하기 어려움 | 파이프라이닝하기 용이함 |


  - 내가 만든 CPU는 CPU마다 명령어가 다르다. 
  
  - CPU가 사용하는 명령어 집합을 의미하는게 Instruction Set Architecture(ISA) 이다.  ISA를 어떤것을 사용하느냐에 따라서 사용자가 작성하는 프로그램을 이해나는게 달라지게 되고, 성능에도 엄청난 영향을 끼친다.

  - CPU가 어떤 명령어집합을 사용하는지에 따라서 소프트웨어가 하드웨어를 사용하는 양상이 달라지고, 그것에 따라 성능까지 달라질수 있다.

  - 즉 위처럼 우리는 CICS,RICS 2가지의 명령어집합을 사용하는 각각의 CPU계열이 있다.

RISC같은 CISC를 만들어서 즉, 명령어를 한번더 쪼개서 클럭수를 일정하게 맞추는 형태인 마이크로 명령어를 이용하여 CISC를 RISC처럼 규격화되어 있는 파이프라이닝을 사용할수 있게 INTEL에서는 제공하고 있다.

그런데, RISC의 명령어는 실제로 단순하지 않다. 점점 복잡해지고 있거든. 즉, 전부다 1~1.5CPI에서 처리되고 단순한 명령어로 모든게 처리되지는 않는다.


### 4-7. 비순차적명령어처리

명령어 파이프라인의 성능을 더 높일 수 있을까? 

: 비순차적 명령어 처리(Out of Order Execution,OoOE)기법을 사용하면 된다.<br>

파이프라이닝 내의 의존 관계가 없는 명령어를 순차적으로 처리하지 않는 방법
(파이프라이닝 harzard 를 우회할수 있는 방법중 하나이다.)

#### 4-7-1. 예제

명령어를 순차적으로만 실행해서는 성능 향상에 실패하는 경우가 있다!

아래 명령어는 모두 (성능 저하 없이) 파이프라이닝 가능할까?

```
1. M(100) <- 1                ## 메모리 100번지에 1이라는 값을 저장해라
2. M(101) <- 2
3. M(102) <- M(100) + M(101)
4. M(150) <- 1
5. M(151) <- 2
6. M(152) <- 3
```

<img width="379" alt="Image" src="https://github.com/user-attachments/assets/926766fb-c076-4253-af99-f93331294b24" />

  -  No : 1,2번명령어가 다 끝아야 3번명령어 실행이 가능하다.  즉, 명령어에 의존관계가 있다. 이런 경우는 완전히 파이프라이닝 하기가 어렵다.

하지만 만약 3번 명령어의 순서를 바꾸어 실행한다면?

  - 문제가 없다. 명령어 의존을 자연히 해결하여 파이프라이닝 실패도 방지한다.

```
1. M(100) <- 1                
2. M(101) <- 2
4. M(150) <- 1
5. M(151) <- 2
6. M(152) <- 3
3. M(102) <- M(100) + M(101)
```

즉, 순서를 바꾸어 실행해도 프로그램 실행에 없는(결과값에 어떠한 영향도 끼치지 않는) 명령어 순서를 바꿈으로써 파이프라이닝의 성능을 높이는 기능을 비순차적 명령어 처리라 한다.

결론적으로 의존관계가 있는지 없는지 판단하는 CPU여야 성능이 더 좋다.


## 5. 메인 메모리와 캐시 메모리

<img width="422" alt="Image" src="https://github.com/user-attachments/assets/61855102-900e-4997-8e06-650792b707d3" />

메인 메모리로 사용되는 두 개의 하드웨어 

1. RAM(Random Access Memory) : 휘발성 저장장치

  - 어떤 주소에 접근하더라도 소요되는 시간은 동일하다.즉, 임의의 접근이 가능한 메모리


<img width="665" alt="Image" src="https://github.com/user-attachments/assets/b7abd0b1-c9b1-4ba3-9655-b36dd7e0ec6d" />

  - memory에는 실행해야 할 데이터가 저장이 되어야 하고, Disk에는 저장해야 할 데이터가 있어야 한다. 만약 Power off되면 RAM에 있는 즉, memory에 있는 데이터는 사라진다.

1-1. RAM의 종류
  - DRAM(Dynamic RAM) : 시간이 지나면 점차 저장된 데이터가 사라지는 RAM(메인 메모리에서 주로 사용되는 RAM)
    - 저장된 내용이 사라지지 않도록 주기적으로 재충전(refresh)를 해준다.
    - 집적도가 높기때문에 대용량으로 설계하기에 용이하다.
  - SRAM(Static RAM) : 시간이 지나도 저장된 데이터가 사라지지 않는 RAM (캐시 메모리에서 주로 사용되는 RAM)
    - SRAM도 휘발성저장장치 이다. 점차 사라지진 않지만 power off하면 사라진다. 다만, 재충전(refresh)할 필요가 없다.

> 집적도 ? <br>
: 얼마나 해당 장치를 빽빽하게 설계할수 있는가를 의미. 빽빽하게 설계할수 있다면 데이터를 더 오밀조밀하게 저장할수 있음을 시사한다.

| - | DRAM | SRAM |
| --- | --- | --- |
| 재충전 | 필요함 | 필요없음 |
|속도 | 느림 | 빠름 |
| 가격 | 저렴함 | 비쌈 |
| 집적도 | 높음 | 낮음 |
| 소비전력 | 적음 | 높음 |
| 사용용도 | 주기억장치(RAM) | 캐시메모리 |

  - SDRAM(Synchromous Dynamic RAM) : 클럭과 동기화된 RAM (클럭의 타이밍에 맞춰 CPU와 정보를 주고받을 수 있는 RAM) , SDRAM(SDR;Single Data Rate RAM))
  - DDRSDRAM(Double Data Rate SDRAM) : 대역폭을 넓혀 속도를 높인 RAM (

  <img width="479" alt="Image" src="https://github.com/user-attachments/assets/098bad62-985f-49be-aebc-723f75d3a773" />

> 대역폭 ? <br>
: 해당 메모리에 접근하기 위한 통로의 넓이라고 생각해라.

  - DDR2 SDRAM : DDR SDRAM 보다 대역폭 두배 넓은 RAM (DDR SDRAM보다 대역폭이 두배 넓은 SDRAM, 즉, SDR보다 4배 넓은 RAM)

  - DDR3 SDRAM : 대역폭을 넓혀 속도를 높인 RAM (DDR2 SDRAM보다 대역폭이 두배 넓은 SDRAM)

2. ROM(Read Only Memory)
  - 비석과도 같은 저장장치
  - 냉장고, 전자레인지, 게임기, 텔레비젼과 같은 가전제품에서도 많이 사용
  - 부팅시에, 부팅의 대상이되는 애를 가장먼저 실행될수 있게끔 하는 저장장치로 사용된다. 즉, Firmware가 저장되어 있다.

2-1. ROM의 종류
  - Mask ROM : 가장 기본적인 형태의 RAM
    - 제조 과정에서 저장할 내용을 미리 기록
    - (옛날에 많이 사용) 냉장고, 전자레인지, 텔레비전, 게임기

    <img width="324" alt="Image" src="https://github.com/user-attachments/assets/f29f27c8-904a-43b3-a28c-af80f4523126" />

  - PROM(Programmable ROM) : 데이터를 한번 새길 수 있는 ROM, 한번에 한해 사용자가 직접 원하는 데이터를 써넣을 수 있는 ROM(비어 있는 PROM)을 얻어 안에 원하는 내용을 한 번 새기기 가능.

  <img width="388" alt="Image" src="https://github.com/user-attachments/assets/9a763429-61e5-4bbb-9098-d614b24fc8e4" />

  - EPROM(Erasable PROM) : 지우고 다시 저장 가능한 PROM
    - 자외선 혹은 전기를 이용해 지우기 가능
      - 자외선을 이용해 데이터를 지울 수 있는 ROM : UVEPROM (Ultra-Violet PROM)
      - 고전압의 전기 신호를 이용해 데이터를 지울 수 있는 ROM : EEPROM (Electrically Erasable PROM)

  <img width="385" alt="Image" src="https://github.com/user-attachments/assets/9f997a37-db75-4563-82ef-2be922c2573e" />

  - 플래시 메모리 : EEPROM의 발전된, 절며한 형태, 반도체 기반의 저장장치

    - 메인 메모리 범주에 속한다기보다는 '범용성 넓은 저장장치'
    - 사실상 대부분의 가전제품에서 활용
    - 보조기억장치로도 사용 (USB Memory, SD카드, SSD)

  <img width="190" alt="Image" src="https://github.com/user-attachments/assets/7dd01ffc-0a56-401f-aa78-f6743a6b5aec" />

### 5-1. 리틀 엔디안과 빅 엔디안

메모리에 데이터를 밀어넣는 순서

- 일반적으로 메모리는 바이트 단위로 저장
- 하지만 CPU로부터 메모리가 받아들이는 데이터는 4 바이트(32bit), 혹은 8 바이트(64bit) **워드(Word)단위**
- 1 바이트씩 저장하는 메모리의 경우 : 4바이트 데이터가 1 Word라면,  네 개의 주소에 걸쳐 저장됨. 8바이트 데이터가 1Word라면, 여덟 개의 주소에 걸쳐 저장됨.

ex) 1A2B 3C4D(16)는 1A,2B,3C,4D로 한바이트씩 나누어 4개의 주소에 걸쳐 저장(16진수를 2진수로 바꾸면 쉽게 이해하기 쉽다)
1A2B 3C4D 5A6B 7C8D는 1A, 2B, 3C, 4D, 5A, 6B, 7C, 8D로 8개의 주소에 걸쳐 나누어 저장

#### 5-1-1. 엔디안

연속해서 저장해야 하는 바이트를 저장하는 순서

나라맏 글을 읽는 순서가 다르듯, 메모리에 바이트를 밀어넣는 순서도 다르다.(ex.리틀 엔디안, 빅엔디안, 바이엔디안), 즉 CPU가 메모리를 읽어들이는 순서도 다를수 있다.(CPU가 메모리에 접근하고 저장하고 읽어들이는 순서도 다를수 있다)

#### 5-1-2. 빅 엔디안

Register에 있는 상위바이트 부터 낮은 번지 주소에 저장하는 방식

  - 여기서 상위 바이트란 수를 이루는 가장 큰 값(MSB, Most Significant Bit, 최상위 비트 )
  - Ex) 1A2B 3C4D에서 최상위 바이트는 1A
    - 하나의 번지에 한 바이트만 저장할수 있는 메모리시스템이 있다면, 해당 데이터(1A2B 3C4D)를 한번에 저장할수는 없다. 그래서 1 바이트씩 나누어서 저장해야 한다.

<img width="248" alt="Image" src="https://github.com/user-attachments/assets/9af2bb1a-35ac-4ffb-8f31-19440a93ef4b" />


#### 5-1-3. 리틀 엔디안

Register에 있는 하위 바이트 부터 낮은 번지주소에 저장하는 방식
  - 여기서 하위 바이트란 수를 이루는 가장 작은 값(LSB, Least Significant Bit, 최하위비트)
    - Ex) 1A2B 3C4D 에서 최하위 바이트는 4D
<img width="265" alt="Image" src="https://github.com/user-attachments/assets/6661b60c-41ff-4590-92d0-76c7103f4eb5" />

문자를 저장할 때에도 마찬가지. (문자도 16진수 or 2진수로 표현 가능)
<img width="632" alt="Image" src="https://github.com/user-attachments/assets/e8ff7fef-c9fd-479c-b346-bd038e13aa8a" />

장단점
  - 빅엔디안
      - 일상적이고 읽고 쓰는 숫자 체계를 읽는 순서와 동일하기 때문에 메모리 값을 직접 읽기 편리 (디버깅)
      - 빅 엔디안 방식으로 주소에 1A, 2D, 3C, 4D로 저장된 값은 그대로 1A2D3C4D로 읽으면 그만
  - 리틀 엔디안
    - 수치 계산(자리 올림 등)이 편리

정리)
- 서로 다른 시스템 간에 데이터를 전송할 때에는 엔디안을 고려해야 한다.
- NUXI Problem: 엔디안을 고려하지 않아 "UNIX"가 "NUXI"꼴로 보인 문제
- 오늘날 데이터 송수신 간에 사용자가 엔디안을 고려하지 않는 이유는 네트워크 전송시 엔디안이 빅 엔디안으로 통일되었기 때문.
  - 수치계산(자리올림 등)의 solution

  1. 정수 연산과 자리올림
정수 계산에서는 엔디안 차이가 문제되지 않습니다.
CPU가 사용하는 내부 ALU(Arithmetic Logic Unit) 는 데이터를 로드할 때 자신의 아키텍처에 맞게 해석하여 연산을 수행합니다. 예를 들어:

네트워크에서 빅 엔디안으로 온 데이터를 리틀 엔디안 CPU 가 사용해야 한다면, 시스템 호출(ntohl, htonl 등)을 통해 변환한 후 연산을 수행합니다.
연산이 완료되면 다시 네트워크 전송을 위해 빅 엔디안으로 변환합니다.
따라서, 정수 연산에서 자리올림 등의 이슈는 엔디안과 무관하게, CPU가 내부적으로 처리할 때 항상 올바르게 수행됩니다.

2. 부동소수점 연산(Floating Point)
부동소수점 연산에서는 엔디안 차이로 인해 값이 다르게 해석될 위험이 있습니다. 하지만 다음과 같은 방식으로 문제를 방지합니다.

(1) IEEE 754 표준
현대적인 컴퓨터 시스템에서는 IEEE 754 부동소수점 표준을 사용합니다. 이 표준에서는:

부호(Sign)
지수(Exponent)
가수(Mantissa, Significand)
이 정해진 비트 패턴을 따르므로, 같은 값이면 모든 시스템에서 동일한 메모리 구조를 가집니다.
그러나, IEEE 754 숫자를 전송할 때 엔디안 차이가 발생할 수 있습니다.
예를 들어, float(4바이트) 또는 double(8바이트) 데이터를 네트워크로 전송할 때,

빅 엔디안 시스템에서는 0x12345678이 [12][34][56][78] 로 저장되지만
리틀 엔디안 시스템에서는 [78][56][34][12]로 저장됩니다.
이를 해결하기 위해, 일반적으로 부동소수점 데이터를 네트워크 전송 전에 정수형으로 변환한 후, 네트워크 바이트 순서(빅 엔디안)로 맞춰 보냅니다.

```C
#include <arpa/inet.h>  // 네트워크 바이트 변환 함수
#include <stdint.h>
#include <string.h>

// 부동소수점 데이터를 네트워크 전송을 위해 변환
uint32_t float_to_network(float value) {
    uint32_t temp;
    memcpy(&temp, &value, sizeof(float));  // float을 32비트 정수로 변환
    return htonl(temp);  // 빅 엔디안으로 변환
}

// 수신 후 다시 부동소수점으로 변환
float network_to_float(uint32_t net_value) {
    uint32_t temp = ntohl(net_value);  // 리틀 엔디안이면 변환
    float result;
    memcpy(&result, &temp, sizeof(float));  // 다시 float로 변환
    return result;
}


```

-네트워크 전송은 빅 엔디안을 사용하므로, 송수신 시에는 htonl, ntohl 같은 변환 함수를 활용하면 됩니다.
-정수 연산에서는 엔디안 변환 후 연산을 수행하므로 자리올림 등의 이슈가 발생하지 않습니다.
-부동소수점 연산은 IEEE 754 표준을 따르지만, 엔디안 문제를 피하기 위해 정수형으로 변환 후 전송하는 방식을 사용합니다.

### 5-2. 논리주소와 물리주소
(ch5-3.주소공간에서 전체복습부분한번보자)

실행 중인 프로그램이 적재되는 메모리 주소는 시시때때 바뀔 수 있다.

같은 프로그램을 2번 실행하면 다른 메모리에 적재될 수 있다.

그런데, CPU와 실행 중인 프로그램은 현재 메모리 몇 번지에 무엇이 저장되어 있는지 전부 알고 있을까?
  - No. 불가능하다.
  - 그렇다면 어떻게 CPU는 시시 때때로 적재된 프로그램의 주소를 찾아가는 걸까?
  - 나아가서, 적재되어 있는 실행프로그램은 어떻게 메모리에 적재되어 있는것과 상호작용할수 있는가?
  - 또한, CPU와 프로그램이 참조하는 주소는 어디일까?

사실 주소 체계에는 논리주소, 물리주소 이렇게 2가지 종류가 있다

- 논리주소(=가상주소) : CPU와 실행 중인 프로그램이 사용하는 주소(0번지부터 시작)
  - 실행하는 프로그램마다 논리주소가 있다.
  - 즉, 0번지라는 논리주소는 얼마든지 다른 프로그램과 중복되서 가질수 있다. 
- 물리주소 : 실제 메로이의 하드웨어 상의 주소
  - 고유한 주소이다.

<img width="511" alt="Image" src="https://github.com/user-attachments/assets/b3de204b-2687-4e1e-b4df-6b08097a740b" />

  - 모든 프로그램은 0번지부터 시작하는 각자의 논리 주소를 사용한다.
  - CPU는 0번지부터 시작하는 각 프로그램의 논리 주소를 인출/해석/실행 한다.
  - 메모리 상에서 사용하는 주소는 물리주소이다.
  - 현재 3개의 프로그램이 실행되고 있다. 인터넷브라우저 크기는 A만큼이다
  - CPU가 실제로 참조하는 주소는 논리주소이다. 즉, 인터넷브라우저는 0~A번지의 논리주소를 참조, 게임은 0~B번지의 논리주소를 참조한다.
  - 프로그램간의 상호작용을 할때도 논리주소를 이용한다.

#### 5-2-1. 주소 변환

CPU/프로그램이 사용하는 주소 체계(논리주소)와 메모리가 사용하는 주소 체계(물리주소)가 다르다면 어떻게 문제없이 부품 간 통신이 가능할까?

CPU와 메모리 사이의 주소 변환이 이루어지면 된다.
    
<img width="523" alt="Image" src="https://github.com/user-attachments/assets/597a1286-d579-4529-add5-dc178e49d699" />

  - 논리 주소와 물리 주소 간의 변환을 담당하는 장치 : MMU(Memory Management Unit)
    - MMU는 CPU와 메모리사이에 위치해서 논리주소와 물리주소의 변환을 담당한다.

#### 5-2-2. MMU의 기본동작


<img width="593" alt="Image" src="https://github.com/user-attachments/assets/e83a717a-04ff-49e1-821d-e6bc98e39543" />

  - 베이스 레지스터를 활용한 주소 변환

  - 베이지 레지스터 = 기준주소로 활용한다(=물리 메모리주소 상에 실제 저장된 첫 주소)

  - 논리주소 = 기준 주소로부터 떨어진 거리 = 변위로 삼는다.(CPU가 접근하고자 하는 주소이다.)

즉, 기준주소 + 변위를 더함으로써 물리주소를 얻게 된다.

  - Ex) 프로그램이 메모리상에 15000~20000 주소에 적재되어 있다면, 베이스레지스터에는 15000이 저장되어 있겠지. CPU는 논리주소만 발생시키면 된다. 만약 프로그램에서 15100 물리주소에 접근하고 싶다면 논리주소100만 발생시키면 된다.

> 한계레지스터 <br> 
: CPU가 접근해도 무방한 최대 물리주소를 제한하기 위한 레지스터.

  - Ex) 만약 CPU에게 25000주소 데이터 삭제하라고 했는데, 그건 프로그램 A가 아닌 프로그램 B라면 지우면 안된다다.이런걸 제한하기 위한 레지스터이다. <br>
즉, 한계레지스터에는 프로그램 크기가 저장된다.

### 5-3. 저장장치 계층 구조와 캐시 메모리

CPU가 멀어질수록 달라지는 저장장치의 특성
  - CPU와 멀어질수록 : 속도 느려짐, 가격 low, 용량 커짐

  1. CPU와 가까운 저장장치는 빠르고, 멀리 있는 저장장치는 느리다.
  2. 속도가 빠른 저장 장치는 용량이 작고, 가격이 비싸다.

  - 빠른 접근 속도와 큰 용량이 양립하기 어려운 이유

CPU와 가까운 순서대로 저장장치를 간략하게 그려본다면?
다음과 같이 CPU와 가까운 순으로 저장 장치를 계층적으로 나타낸것: 저장장치 계층구조

<img width="507" alt="Image" src="https://github.com/user-attachments/assets/df9f0b99-0d0f-4e57-99cf-2d0d029dc452" />

  - 레지스터와 메모리 간의 속도 차이 주목해보기
    - CPU가 아무리 빨리 정보를 처리해도 메모리가 발맞춰주지 않으면 말짱 헛수고!

    - 그래서 등장한 캐시메모리!
      - CPU와 메모리 간의 속도 차를 극복하기 위해 탄생
      - CPU와 메모리 사이에 위치, 레지스터보다 용량이 크고 메모리보다 빠른 SRAM기반
      - CPU에서 사용할 법한 정보를 미리 가져와(예측해서 가져옴) 저장
      - 메모리가 대형 마트라면 캐시 메모리는 편의점
       
여러 단계의 캐시 메모리
  - L1(level 1)캐시 메모리 : CPU와 가깝고 용량 작음
  - L2(level 2)캐시 메모리
  - L3(level 3)캐시 메모리 : CPU와 멀고 용량 큼
  - 분리형 캐시 : L1D(데이터 저장) + L1I(명령어 저장, I는 Instruct의 약자)
    - 데이터 접근과 명령어 접근을 따로 나누어서 조금더 빠르게 접근 가능능
<img width="533" alt="Image" src="https://github.com/user-attachments/assets/4de74977-35d0-401a-b9be-e09e83c8a8ca" />

<img width="548" alt="Image" src="https://github.com/user-attachments/assets/db20adc7-9eb7-4543-b7c0-e6edddbd4424" />

<img width="547" alt="Image" src="https://github.com/user-attachments/assets/2730336a-7623-4210-95f1-e5e608d6945b" />

  - L3캐시메모리는 여러개의 코어가 공유할수 있도록 할수도 있다.
> 캐시의 일관성 <br>
: 각 캐시메모리에 저장된 값이 다를수 있다. 그래서 일관성을 위해 주기적으로 메모리에 저장을(쓰이게 된다) 한다.
 
캐시 메모리에 데이터가 있을때와 없을때
  - 캐시 메모리는 CPU에서 사용할 법한 내용을 미리 가져와 저장한다
  - 캐시 메모리에 CPU가 요구하는 정보가 있을경우 : 캐시히트(메모리접근 X)
  - 캐시 메모리에 CPU가 요구하는 정보가 없을경우 : 캐시 미스(메모리 접근)

  - 캐시 히트율 : 캐시히트 횟수 / (캐시히트횟수 + 캐시미스횟수)

캐시 메모리는 어떤 데이터를 저장할까?
  - CPU가 자중 사용할 법한 내용
  - 그렇다면 CPU가 자주 사용할 법한 내용은 어떻게 예측할까?
    - **참조 지역성의 원리(locality of reference)**
      1. 시간 지역성 : CPU는 최근에 접근했던 메모리 공간에 다시 접근하려는 경향이 있다.
        ```C
        # include <stdio.h>

        int main() {
          int num;

          printf("구구단을 출력할 숫자를 입력하세요 : ");
          scanf("%d", &num);

          printf("%d단을 출력합니다:\n", num);

          for (int i = 1; i <= 9; i++) {
            printf("%d x %d = %d\n", num, i, num * i);
          }

          return 0;
        }
        ```
          - i라는 변수는 반복문때문에 여러번 참조된다.
          - 즉, 시간지역성의 가장 큰 예시로 변수가 있다.

      2. 공간 지역성 : CPU는 접근한 메모리 공간 근처를 접근하려는 경향이 있다.

        <img width="460" alt="Image" src="https://github.com/user-attachments/assets/65c5b2e4-a7c5-468c-b9a8-607f30234a13" />
          
          - 실제 메모리 배치를 보면 된다.
          - CPU가 접근하려는 메모리 근처에 유관한 내용이 모여있는 특성

캐시메모리에 적중률을 높일수 있는 코드를 캐시 친화적 코드라고 한다.

캐시 친화적 코드 : 캐시 미스가 최소화되는 코드
  - 시간 지역성 / 공간 지역성을 준수하는 코드

```python
# matrix 라는 변수 생성
# 10000 x 10000 크기의 2차원 리스트(또는 배열) 저장
# 이 리스트의 모든 요소를 0으로 초기화
matrix = [[0] * 10000 for _ in range (10000)]

for i in range(10000):
  for j in range(10000):
    matrix[i][j] = 1  # 캐시 친화적인 코드
    # matrix[j][i] = 1  # 캐시 친화적이지 않은 코드
```

  - 메모리에 저장되는 순서는 2차원 배열에선 행이 기본적으로 나란히 저장히 된다. 즉, 메모리에 저장되는 순서와 matrix에 1을 저장하는 순서가 똑같다.
  - 캐시 친화적이지 않은 코드는 열순으로 접근하게 된다. 즉, 이건 메모리에 순차적으로 접근하는게 아니다.

```shell
$ time python cache_friendly.py # time뒤에 실행한되는것의 시간측정 가능.
```

즉, 코드만들때 캐시 미스가 최소화되도록 코드를 만들어야 한다.

## 6. 보조기억장치와 입출력 장치

보조기억장치
1. 하드 디스크 드라이브

<img width="188" alt="Image" src="https://github.com/user-attachments/assets/ac2ff254-fe89-46d9-8ff5-64f2888df2a3" />

  - 플래터 : 하드디스크 상에서 실질적으로 데이터가 저장되는 부분
    - 자기적인 방식으로 데이터가 저장된다.
    - 플래터에는 수많은 N극, S극이 존재한다.
  - 스핀들 : 플래터를 회전시키는 부분
    - N극,S극을 돌려서 작동시키게 하는 부분이다.

<img width="239" alt="Image" src="https://github.com/user-attachments/assets/ca9df7ac-4ef2-4a9b-92b7-95d0c5b4352c" />

  - 헤드 : 플래터의 데이터를 읽고 쓰는 부분
  - 디스크 암 : 헤드를 옮기는 부분

<img width="208" alt="Image" src="https://github.com/user-attachments/assets/2f626f98-42c3-4a86-90e2-0f693714a462" />

  - 복수의 헤드와 플래터가 있는 경우가 많음
  - 플래터의 양면을 사용하는 경우가 많음

하드 디스크의 데이터 단뒤

<img width="217" alt="Image" src="https://github.com/user-attachments/assets/61dc96a4-476b-41a8-8f53-eb92462a50ad" />

  - 트랙 : 플래터 상의 동심원
  - 섹터 : 트랙을 나눈 단위(하드디스크에서 가장 작은 단위로 저장할수 있는 단위)
    - 실제 컴퓨터와 정보를 주고받는 가장 작은 단위는 블록이란 단위이다. 
  - 실린더 : 여러 개의 트랙을 모은 단위
    - 연속적인 데이터는 실린더에 저장되는 경우가 많다.
  - 블록 : 실제 입출력이 수행되는 단위(여러개의 섹터를 모은 단위)

하드 디스크의 지연 시간

<img width="691" alt="Image" src="https://github.com/user-attachments/assets/2cf7f9c5-d547-4c0e-be0d-0e7cfca199f8" />
  - 탐색시간 : 헤드를 원하는 트랙까지 이동시키는 시간
  - 회전 지연 : 원하는 섹터를 헤더까지 회전시키는 시간
  - 전송 시간 : 데이터를 송수신하는 시간

하드 디스크의 지연 시간
 
| 내용 | 지연시간 |
| --- | --- |
| L1캐시 참조 시간 | 0.5ns |
| L2캐시 참조 시간 | 5ns |
| 메모리 참조 시간 | 7ns |
| 메모리에서 1MB를 순차적으로 읽는 시간 | 250,000ns |
| (하드) 디스크 탐색 시간 | 10,000,000ns |
| (하드) 디스크에서 1MB를 순차적으로 읽는 시간 | 30,000,000ns |
| 한 패킷이 캘리포니아에서 네덜란드까지 왕복하는 시간 | 150,000,000ns |


2. 플래시 메모리

- 반도체 기반의 저장장치
- 매우 범용성 넓은 저장장치
- NAND플래시 메모리와 NOR플래시 메모리가 있음 : 일반적으로 사용되는 것은 NAND플래시 메모리

플래시 메모리의 저장 단위
  - cell : 플래시 메모리의 가장 작은 저장 단위
  - 한 셀에 몇 비트까지 저장이 가능한지에 따라 플래시 메모리의 종류가 나뉨

  <img width="437" alt="Image" src="https://github.com/user-attachments/assets/208a5dba-92d8-4bcd-b074-32253ad2dc1b" />

    - SLC타입 : 한 셀에 한 비트 저장 가능
    - MLC타입 : 한 셀에 두 비트 저장 가능
    - TLC타입 : 한 셀에 세 비트 저장 가능
    - QLC타입 : 한 셀에 네 비트 저장 가능
  
    - 셀 당 bit, 수명, 읽기/쓰기 속도, 안정성, 가격등의 특성이 다르다.
    - ex) 사람 = 비트 / 셀 = 집으로 생각해라.
      - SLC는 한 집당 한명이 살수있다.
      - MLC는 한 집당 두명이 살수 있다.
      - 혼자 월세 부과하는것보다 두명이 훨세 부과하는게 가격이 더 싸지.
      - 여러명이 외출준비하는것보다 혼자 외출준비가 더 빠르다. 그래서 입출력 속도가 혼자가 더 빠르다.
      - 혼자 사는집이 수명이 더 길다. 더 깨끗하니깐.

      | - | SLC | MLC | TLC |
      | --- | --- | --- | --- |
      | 셀 당 bit | 1bit | 2bit | 3bit |
      | 수명 | 김 | 보통 | 짧음 |
      | 읽기/쓰기 속도 | 빠름 | 보통 | 느림 |
      | 안정성 | 높음 | 보통 | 낮음 |
      | 가격 | 높음 | 보통 | 낮음 |

<img width="233" alt="Image" src="https://github.com/user-attachments/assets/7adfaa44-7937-4a48-8b95-0b4be7ae732d" />

  - **읽기와 쓰기는 페이지 단위**
  - **삭제는 블록단위**
  - cell 이 모여서 페이지 단위가 되고 그게 모여, 블록 < 플레인 < 다이 단위가 된다.
  - 하드디스크에서는 읽기/쓰기/삭제/덮어쓰기 등 단위가 동일했음. 그러나 플래시 메모리에서는 읽기/쓰기 와 삭제 단위가 다르다.
  
### 6-1. RAID

쏟아지는 정보들을 어떻게 안전하게, 안정적으로 저장할 수 있을까?
  - 보조기억장치에는 수명이 있다 : 단순히 저장하는 것만으로도 정말 괜찮을까?
  - 이때 사용 가능한 기술 중 하나 : RAID
  - 데이터의 안정성, 높은 성능을 위해 여러 보조기억장치를 하나처럼 사용 가능한 기술

RAID레벨 (= RAID를 구성하는 방법)
  - RAID0,1,2,3,4,5,6,10(일영),50(오영)...

#### 6-1-1. RAID 0

  <img width="432" alt="Image" src="https://github.com/user-attachments/assets/60837666-19e3-4bbc-b0ad-520e20bf2616" />

  - 데이터를 단순히 보조기억장치에 나누어 저장하는 구성 방식 : (장점)성능 개선 / (단점)신뢰성은 감소
    - 데이터를 차곡차곡 저장하는방식이다.
    - A 데이터를 찾기위해 동시에 접근가능.
    - 만약 하드디스크1에 A1,A2,A3,A4가 모두 저장되어있다면 4번접근해서 데이터 찾는게 된다.
    - 하드디스크 3이 고장나면 안에 있는 데이터 모두 사용 못함. 그러면 A3을 사용못하니,  A1,A2,A4만 읽게 되고 , 순차적으로 읽을수가 없음.즉, 신뢰성이 감소
  - 마치 줄무늬처럼 저장된 데이터 : 스트라입(strip)
  - 분산하여 저장하는 것 : 스트라이핑
  - 4TB로 저장하기 위해  1TB x 4개로 저장하기 위한것.
  
#### 6-1-2. RAID 1

<img width="444" alt="Image" src="https://github.com/user-attachments/assets/589b91eb-9351-464b-94b3-3d1d1bf6593a" />

  - 복사본을 만드는 방식(미러링)
  - 쓰기 성능의 감소, 저장 공간 감소, 신뢰성 증가(복구 용이)
  - 2TB데이터를 1TB x 4개에 저장하는 방식.
  - 쓰기할때는 미러링된 대상에도 저장되기 때문에 2번씩 저장된다. 그래서 쓰기 성능이 감소.
  - RAID 0은 A1~ D4의 데이터를 4TB에 저장할수 있었지만, RAID 1 은 줄어든 A1 ~ D2의 데이터를 저장해야하며, 이를 4TB에 저장하기 위해선 2TB만 저장할수 있게 된다. 그래서 저장공간 감소.

#### 6-1-3. RAID 4

<img width="470" alt="Image" src="https://github.com/user-attachments/assets/8282674a-43a3-4d2c-b54c-515209f79016" />

  - 패리티 비트(parity bit)라는 오류 검출용 비트를 저장하는 장치를 따로 두는 방식
  - RAID 1에 비해 적은 하드 디스크로도 신뢰성 증가 가능   
  - parity bit를 저장하기 위한 하드디스크를 따로 두는것이다. 그래서 오류 검사할수 있는걸 해당 하드디스크에 몰빵하고, 나머지에다가 striping하면 되는것이다.
  - 만약 하드디스크3의 A3가 문제가 생기더라도, parity bit는 원래 오류 검출 및 RAID상에서는 정정도 가능한 역할을 한다.즉, A3 데이터가 문제생겨도 어느정도 복구를 해준다.  
  - 단, 패리티 비트를 저장한 디스크에 병목현상이 증가.
    - 하드디스크 1에 접근하려 해도 Parity bit A를 참조해야하며, 하드디스크 2에 접근하려고 해도 Parity bit A를 참조해야 한다. 즉, 하드디시크 4만 바빠진다. 즉, 하드디스크 4에 병목현상이 증가할수 있다.

> 패리티 비트 ? <br>

<img width="450" alt="Image" src="https://github.com/user-attachments/assets/d8e2846b-8c35-4789-afa9-25372dc10b10" />


1. 홀수 패리티 : 전체 1의 개수가 홀수가 되도록 패리티 비트를 정하는 방식
2. 짝수 패리티 : 전체 1의 개수가 짝수가 되도록 패리티 비트를 정하는 방식
3. 2개 이상의 비트에 문제가 생길 경우 오류 검출 불가능

<img width="573" alt="Image" src="https://github.com/user-attachments/assets/fd0c0fe1-0e5f-4288-927e-7e930dd5dcd3" />

  - 본래 패리티 비트는 오류 검출용 비트일 뿐, 복구는 불가능
  - but, RAID에서는 어느 정도의 복구가 가능
    - RAID에서는 전체 디스크의 개수에서 쓰기 위한 데이터의 저장공간이 저장되어 있기 때문에 쓰고자 하는 공간은 이미 정해져 있다.그래서 어느정도 판단해서 패리티 비트로 어느정도의 복구는 가능.
    - 그러나 2개 이상 데이터가 오류나면 패리티 비트가 검출 못할수도 있다.

#### 6-1-4. RAID 5

<img width="397" alt="Image" src="https://github.com/user-attachments/assets/63bd8aa7-4169-4dc7-8559-f4ba91962b17" />

  - 패리티 비트를 분산하여 저장하는 방식
  - RAID 4의 병목을 해소하는 방식

#### 6-1-7. RAID 6

<img width="471" alt="Image" src="https://github.com/user-attachments/assets/8439cc50-1224-4e70-9506-59130b2b23cd" />

  - 패리티를 2개 두는 방식
  - RAID 4 or RAID 5 보다 더욱 신뢰성이 높아진 방식 (단, 쓰기 성능은 감소)
    - 패리티 비트를 2개나 쓰기 때문에 쓰기 성능은 감소된다.

#### 6-1-8. nested RAID

<img width="424" alt="Image" src="https://github.com/user-attachments/assets/716edbfd-a65b-4a3a-a517-04217f64ad31" />

  - 여러 RAID 구성방식을 합친 방식
  - RAID 10(RAID 1 + RAID 0), RAID 50 (RAID 5 + RAID 0)
    - RAID 1과 RAID 0 구성방식을 합친 방식 
    - RAID 1 구성방식으로 2개를 미러링하고,나머지에 대해서는 striping하는 방식.

### 6-2. 입출력 기법

입출력장치 vs 보조기억장치
  - 보조기억장치도 입출력장치의 일부로 볼 수 있다(주변 장치)
  - 그저 특별한 입출력 장치일 뿐
  - 보조기억장치의 입출력 과정은 타 입출력장치와 유사하다.

입출력장치와 CPU는 어떻게 정보를 주고받을까?
  - 입출력 장치는 CPU입장에서 메모리, 레지스터에 비해 다루기 까다롭다. 왜?
    1. 매우 다양한 입출력장치의 종류
    2. CPU와 입출력 장치 간의 전송률 차이
    전송률 ? 한번에 주고받을수 있는 데이터의 양

      - CPU는 일반적으로 전송률이 높다.  입출력은 일반적으로 CPU에 비해 전송률이 낮다.

이를 해결하기 위한 장치 컨트롤러(=입출력제어기, 입출력모듈 이라고도 불림)

<img width="426" alt="Image" src="https://github.com/user-attachments/assets/343a8c50-d486-4006-9e65-12d1f3973e5a" />

  - 초록색 PCB가 장치 컨트롤러부분이다.
  - CPU 와 입출력장치 간의 통신 중개
  - 오류 검출
  - 데이터 버퍼링을 통한 전송률 차이 완화

> 데이터 버퍼링 ? 데이터를 임시로 저장했다 내보내는 것.
> 전송률을 완화하는 버퍼링이란? 데이터를 모았다가 한번에 내보내는거다.

장치드라이버
  - 장치 콘트롤러를 동작시키기 위한 특별한 프로그램
  - 운영체제의 일부로 포함되어 있는 경우가 많음

결국 입출력이란 CPU가 장치 컨트롤러와 정보를 주고받는 것
  - 그를 가능케 하는 프로그램 : 장치 드라이버

CPU와 장치 컨트롤러가 정보를 주고받는 방법
  1. 프로그램 입출력 : 입출력 명령어를 기반으로 입출력을 수행하는 방법
  2. 인터럽트 기반 입출력 : 인터럽트를 기반으로 입출력을 수행하는 방법
    -  인터럽트가 없다면 장치드라이버가 상호작용하면서 CPU를 확인한다.(polling) 
    - 인터럽트 기반이면, 장치드라이버의 상태를 확인할 필요 없이 인터럽트 받으면, 입출력 끝났구나 라고 알고 있기에 조금더 CPU cycle을 절약할수 있다.
  3. **DMA기반 입출력** (기술면접 단골문제) : DMA를 기반으로 입출력을 수행하는 방법
    <img width="520" alt="Image" src="https://github.com/user-attachments/assets/4f9d83a2-be80-45c3-bb90-9a747cd9bf99" />

    - Direct Memory Access(직접메모리 접근방식)
      - 입출력장치와 메모리 간의 데이터 이동을 CPU가 주도하고 이동하는 데이터도 CPU를 거친다면? 
        - DMA 사용방식 아니라면, 메모리에 있는 어떤 데이터를 하드디스크에 백업하고 싶다면 CPU가 메모리로부터 값을 읽어들이고, 이값을 읽어들인 값을 바탕으로 하드디스크 장치컨트롤러에다가 정보를 쏴야한다.  

<img width="548" alt="Image" src="https://github.com/user-attachments/assets/fc2eb7c1-6695-43a1-904c-33f24ceeef8e" />

        - 입출력 장치와 메모리가 CPU를 거치지 않고도 상호 작용할 수 있는 입출력 방식
        - 직접 메모리에 접근 가능한 입출력 기능
        - DMA 컨트롤러가 필요
   
          1. CPU는 입출력 작업을 DMA컨트롤러에게 전달(ex.메모리의 내용을 하드 디스크에 백업)
          2. DMA컨트롤러는 메모리로부터 백업할 정보를 읽어오고, 이를 하드 디스크의 장치 컨트롤러에 내보내기
          3. DMA컨트롤러는 입출력 작업이 끝났다면 인터럽트를 통해 작업이 끝났음을 CPU에게 알림

          - 사이클 스틸링 : CPU입장에서는 시스템 버스를 사용할 사이클을 도둑맞음. 왜? 시스템 버스는 공용자원이거든. 그래서 여러개의 하드웨어가 동시에 시스템 버스를 사용할수가 없다. 한번에 하나의 구성요소만 시스템버스를 사용할수 있다.

          - 입출력 작업이 있을 때마다 시스템 버스를 사용하는것이 좋은걸까?

          <img width="488" alt="Image" src="https://github.com/user-attachments/assets/f44c0d7b-e410-4c5f-a672-ede6b63f4979" />
          
            - 1번,2번 이렇게 DMA컨트롤러가 시스템 버스를 결국 두번 사용하게 된다!
            - 이때 CPU는 시스템버스를 사용못하게 된다.   

이러한 문제점을 해결하기 위해 나온게 입출력버스이다.

<img width="459" alt="Image" src="https://github.com/user-attachments/assets/57f7a32d-47b0-4cb8-a35a-65d36d7f4765" />

입출력버스 ? 입출력 전용버스이다.
<img width="332" alt="Image" src="https://github.com/user-attachments/assets/919bfb9c-ad1c-45b4-8a3a-1eee5c9cdca3" />

이건 DMA 컨트롤러 밑에 있는 버스이다.즉, DMA 컨트롤러가 명령줄때 시스템버스를 사용하지 않아도 된다.
입출력버스 = PCI = PCI Expres(=PCIe)버스 이다.

DMA의 발전 : 입출력 채널
  - 입출력 전용 프로세서
  - 입출력 명령어 해석, 실행까지 전담
  - 이렇게 되면 CPU입장으로서 입출력 작업은 단순히 명령어 전달하고 알림만받으면 끝이다.

### RAM & ROM 학습하기
### 데이터 저장 방식 이해하기
### 캐시메모리의 개념 이해하기

## 보조기억장치와 입출력장치
### HDD, SSD 학습하기
### 입출력 기법 이해하기
---


[맨 위로 이동하기](#){: .btn .btn--primary }{: .align-right}