---
title: "네트워크"
escerpt: "네트워크"

categories:
  - System
tags:
  - [System]

toc: true
toc_sticky: true

breadcrumbs: true

date: 2025-04-12
last_modified_at: 2025-04-12

comments: true
 

---

## 1. 네트워크란?
네트워크 구조, 프로토콜 개념, 성능지표 학습하기

컴퓨터 네트워크
  - 여러 장치들이 서로 정보를 주고 받을 수 있는 `통신망`

인터넷 : 네트워크끼리 연결한 네트워크를 말함
  - LAN (local area network) : 근거리 네트워크

컴퓨터 네트워크 구성요소
  1. 노드(= end system = 종단시스템 = `host`)
    - 메세지를 최초로 송신, 생성하는 대상, 혹은 메시지를 최종적으로 수신하는 대상
    - `주소`를 통해 위치 특정
      - 주소를 통해서 호스트를 특정지을수 있다면 메시지를 어떤식으로 주고받을수 있을지 정할수 있다.
      
        - 유니캐스트 : 1:1통신, 내가 송수신대상이 1대1로 정해진것.
          - ex) 친구랑 1대1 채팅하는것.
        - 브로드캐스트 : 네트워크 범위내에 모든 대상에 전부 메시지를 보내는 송수신방법
          - ex) 공지사항같은것 
        - 멀티캐스트 : 특정 그룹에게만 메시지를 전달해주는 방법

  역할별로 host를 구분할수 있다.
    ![system_network_서버클라이언트.png](/assets/images/system_network_서버클라이언트.png)

      1. 서버 : 응답을 보내는 호스트
      2. 클라이언트 : 요청을 보내는 호스트 
      - 클라이언트와 서버 간의 메시지를 주고받는다 = 클라이언트의 요청에 대해 서버가 응답을 보낸다란 의미
      - 하나의 host가 서버,클라이언트 역할 둘다 할수 있다.단지 역할에 따라 구분한것.

    - (중간)노드
      - 네트워크 장비들은 중간 노드라고 한다.
      - ex) 라우터, 스위치, 공유기..

  2. 메세지
    - 노드들간의 주고받는 정보
    - Ex) 웹페이지, 사진, 동영상...

  3. 간선(통신 링크 = 통신매체)
    - 유선 케이블(Ex.트위스티트 페어 케이블, 광케이블)
    - 무선 (Ex.와이파이)

범위에 따른 네트워크 구분
  ![system_network_LAN_WAN.png](/assets/images/system_network_LAN_WAN.png)

    1. LAN(local area network) : 근거리를 연결한 네트워크
    2. WAN(wide area network) : 원거리를 연결한 네트워크
      - WAN에 접속하기 위한 `수단`이 필요. 
      - 그 수단은 ISP(KT,LG U+, SK브로드밴드)에 의해 구축됨
      - ISP : internet service provider


### 1-2. 프로토콜과 캡슐화

네트워크를 통해 주고받는 정보는 메시지라고 하며, 그 메시지는 패킷단위로 주고받는다.

패킷교환 네트워크   
  - 주고받는 정보를 패킷(packet) 단위로 주고받는 네트워크
  - 패킷이란 패킷 교환 네트워크에서 주고받는 데이터 단위
  - 오늘날의 네트워크는 회선교환이 아닌 패킷교환을 사용한다.

  ![system_network_packet.png](/assets/images/system_network_packet.png)

회선교환 네트워크(패킷교환과 반대개념이다.)
  - 정해진 회선( circuit)으로만 통신하는 네트워크
  - 사전에 연결 수립작업필요
  - 다른 호스트는 도중에 끼어들수 없음
    - 장점 : 전송률 보장
    - 단점 : 회선 이용률 저하
  - ex) 전통적인 전화망


패킷구성요소
  - 헤더(header) : 패킷에 붙일 부가 정보
  - 페이로드(payload) : 패킷에 보낼 정보
  - 트레일러(trailer) : 패킷 뒤에 붙일 부가정보

프로토콜(protocol)
  - 장비 간 정보를 주고받을 규칙이나 방법
  - 호스트 간에 합의된 의사소통 규칙
  - 노드간의 언어가 프로토콜이다.

  ![system_network_protocol.png](/assets/images/system_network_protocol.png)

    - 헤더의 내용은 프로토콜의 영향을 받는다.
    - 프로토콜이 달라지면 헤더의 내용이 달라질 수 있다.

    - TCP : 신뢰성, 오류없이 전송할때 주로 사용
    - UDP : 빠른전송,효율전송이 목표

네트워크 참조모델
  - 송수신 과정에서의 정형화된 단계

    ![system_network_protocol_참조모델.png](/assets/images/system_network_protocol_참조모델.png)

      - 네트워크 단계는 계층으로 표현할수 있고, 네트워크를 송신하는 대상은 고계층-> 낮은계층 순차적으로
      - 수신하는 입장에서는 낮은계층에서 높은 계층순으로 수신하게 된다.(계층외울필요 없음)

  - OSI 7계층 모델 vs TCP/IP 4계층 모델
    ![system_network_protocol_참조모델2.png](/assets/images/system_network_protocol_참조모델2.png)

    - OSI모델(실제 이론적인 목적)
      - `물데네전세표응`
      - 물리계층 : 가장 근원적인 송수신이 이루어지는 계층
        - 0과1로 이루어진 bit를 주고받는 계층, 테이블을 통해 주고받거나, 전자파를 이용해서 혹은 하드웨어단에서 송수신이 이루어지는 계층
      - 데이터링크계층 : 오류제어나 LAN환경에서 주소식별(MAC주소), LAN환경에서의 충돌방지
      - 네트워크 계층 : LAN간의 통신, 네트워크 끼리 통신을 할수 있도록 해주는 계층, IP라는 프로토콜이 사용됨
      - 전송 계층 : 송수신과정에서 신뢰성을 덧붙이고 싶을때 사용되는 전송계층의 역할이 사용됨
        - 내 컴퓨터에 있는 프로그램이 인터넷밖으로 나갈때 어떻게 식별될지에 대한 정보로서 port라고 하는 번호도 같이 사용됨
      - 세션 계층 : 세션이라고 하는 연결관계를 유지하고 수립하는 계층
      - 표현 계층 : 번역가처럼 뭔가를 압축하고 인코딩하는 계층
      - 응용 계층 : 실제로 어플리케이션 프로그램이 동작하는 HTTP가 대표적.
    
    - TCP/IP모델(구현적인 목적)
      - 네트워크 엑세스 계층
      - 인터넷 계층
      - 전송계층
      - 응용계층

캡슐화와 역캡슐화

![system_network_protocol_참조모델3.png](/assets/images/system_network_protocol_참조모델3.png)

  - 캡슐화(encapsulation)
    - 계층을 지날수록 계층에 있는 프로토콜의 목적에 따른 헤더가 추가되는 과정이 캡슐화이다.
    - 상위 계층으로부터 내려받은 패킷을 페이로드로 삼아, 상위 계층으로부터 받은 정보에 프로토콜에 걸맞는 헤더(혹은 트레일러)를 덧붙이는것
    - 계층마다 주로 사용되는 프로토콜이 다르다.
      - 응용계층은 HTTP, 전송계층은 TCP, 네트워크계층은 IP라는 대표적프로토콜이 각각 존재한다.
      - 프로토콜의 종류가 달라지면 헤더의 내용도 달라질수 있다.
      
  - 역캡슐화(decapsulation)
    - 캡슐화 과정에서 붙인 헤더(및 트레일러)를 수신받는 입장의 각 계층에서 제거하는 것

> PDU <br>
: 각 계층에서 캡슐화된 데이터를 부르는 지칭

|OSI계층 | PDU | 
| --- | --- |
| 응용계층,표현계층, 세션계층 | 데이터(data), 메세지 |
| 전송계층 |TCP이용시엔 세그먼트(segment), UDP를 이용시엔 데이터그램(datagram) |
| 네트워크 계층 | IP패킷(packet) |
| 데이터 링크 계층 | 프레임(frame) | 
| 물리계층 | 비트(bit) |
 
### 1-3. 네트워크의 성능

트래픽
  - 특정 시간 동안 네트워크 내 정보 흐름
  - 얼마나 많은 패킷들이 한순간 몰리는가
    - 트래픽이 몰리면 과부하/오버헤드 발생
  - 한 노드를 얼마나 많은 패킷들이 한순가에 경유하는가, 얼마나 많은 패킷이 네트워크 내 한순간에 몰리는가를 말함.

전송속도
  - bps(b/s, bits per second)
  - Mbps(Mb/s, Megabits per second)
  - Gbps(Gb/s, Gigabits per second)
  - 기대 가능한 속도, 즉, 해당 케이블은 어느정도 속도까지 전송이 가능한 기대치를 말해준다.

처리율(Throughput)
  ![system_network_처리율.png](/assets/images/system_network_처리율.png)

    - 실제 내 컴퓨터를 거치는 현실적인 네트워크의 전송속도를 말함
    - bps(b/s, bits per second)
    - Mbps(Mb/s, Megabits per second)
    - Gbps(Gb/s, Gigabits per second)
    - 단위 시간 동안 네트워크를 통해 전송되는 데이터 양

    - send :한번에 어느정도를 보냈고, receive : 일순간에 어느정도를 받았는지 확인 가능

대역폭 (bandwidth)
  - 네트워크 트래픽을 수용할 수 있는 용량
  - 송수신 가능한 최대 데이터 양
  - "전송 매체의 두께"

패킷 손실(packet loss)
  - 얼마나 많은 패킷이 송수신 과정에서 손실되었는가
  - 보통 백분율로 표기
  
  ```shell
  $ ping [IP주소] 
  $ ping -c 5 [IP주소]  // 5개의 패킷을 보내겠다
  ```
    - IP주소에게 network packet을 보낸다.
    
    ![system_network_패킷.png](/assets/images/system_network_패킷.png)

      - 16 packet을 보냈고 16 packet을 받아서 0% loss가 나옴을 확인

### 1-4. wireshark
패킷을 직접 캡처할수 있는 프로그램

[wireshark download](https://www.wireshark.org/download.html)
  - source : 발신주소
  - destination : 목적지주소
  - hex data의 의미 : 실제 packet하나하나를 구성하고 있는 데이터를 의미
    - 패킷에 해당하는 2진수를 16진수로 표현한것이다.
  - 좌측칸의미
    - 캡슐화된 packet을 의미
    - 각각 클릭할때마다(frame, ethernet II, Internet Protocol version 4,,,) hex data에서 어디서부터 어디까지 의미하는바인지 나타내준다.

  - 필터링기능
    - ip.addr == 192.xxx : ip에 해당하는것만 필터링됨
    - tcp : tcp에 해당하는것만 필터링됨
      - tcp.port == 443 : tcp port중에 443인것만 필터링
    - http.response.code == 200
    - ip.src == ip주소 : IP의 발신지 IP주소 기준 필터링
    - ip.drc == ip주소 : ip의 목적지 주소 기준 필터링
    - || : or연산,  && : and연산
  - wireshark를 통해서 throughput을 따로 조사하거나, sequence number조회도 가능


## 2. 네트워크 엑세스 계층(LAN, 근거리네트워크)
이더넷과 네트워크 장비

이더넷이란?

  - WAN -> 인터넷
  - LAN -> 이더넷
  - 현대(유선) LAN에서 가장 대중적으로 사용되는 기술
  - 물리계층, 데이터링크계층(네트워크 엑세스 계층) 스펙/프로토콜 정의

이더넷기술
  
  ![system_network_이더넷.png](/assets/images/system_network_이더넷.png)
    
    - 물리계층 : 이더넷으로 통신이 가능한 케이블은 무엇으로 할지
    - 데이터 링크(=frame) : 이더넷 프레임은 어떤 형태로 주고받을지
  - [이더넷 국제표준 : IEEE 802.3 Ethernet working group](https://www.ieee802.org/3/)

    - 이더넷 표준 규격버전 : 802.3 뒤 알파벳으로 표기
      - 802.3u
      - 802.3ab
    - 이더넷 표준 규격이 달라지면 케이블, 전송속도 등이 달라질수 있다

      | 표준규격 | 전송속도 | 연결매체종류 |
      | --- | --- | --- |
      | 802.3ab | 1Gbit/s | 트위스트 페어 케이블 | 
      | 802.3u | 100 Mbit/s | 트위스트 페어 케이블 | 
      | 802.3ae | 10 Gbit/s | 멀티 모드 광 케이블 |
      | 802.3cc | 25 Gbit.s | 싱글모드 광 케이블 | 

    - 이더넷 케이블을 지칭할때 : `전송속도 BASE-추가특성`
      - 추가특성에 따라 케이블의 종류가 달라진다.광케이블이나 동축케이블이나 등등..
      - ex)
        - 10BASE-T
        - 25GBASE-LR
        - 5GBASE-T
      |표준규격 | 전송 매체 |
      | --- | --- | 
      | IEEE802.3i | 10 BASE T | 
      | IEEE802.3u | 100 BASE TX |
      | IEEE802.3ab | 100G BASE T |
      | IEEE802.3bz | 2.5G BASE T |
      | IEEE802.3an | 10G BASE T | 

      | 전송속도표기 | 의미 |
      | --- | --- |
      | 10 | 10Mbps |
      | 100 | 100Mbps |
      | 1000 | 1Gbps (1000Mbps) |
      | 2.5G | 2.5Gbps |
      | 5G | 5Gbps |
      | 10G | 10Gbps |
      | 40G | 40Gbps |
      | 100G | 100Gbps |

      | 추가 특성 표기 (전송매체의 종류) | 의미 |
      | --- | --- |
      | C | 동축케이블 |
      | T | 트위스티드 페어 케이블 | 
      | S | 멀티 모드 광케이블 |
      | L | 싱글 모드 광케이블 |

        ![system_network_이더넷2.png](/assets/images/system_network_이더넷2.png)


이더넷 프레임 : 이더넷 네트워크에서 주고 받는 데이터 형식이 정해져 있다.

  ![system_network_이더넷4.png](/assets/images/system_network_이더넷4.png)

    - 데이터링크 계층에서 캡슐화 이루어질때 헤더와 더불어 트레일러까지 붙인다.
    - 페이로드 : OSI 7계층에서 네트워크계층으로부터 전달받은 정보이다.
    
    - 프리앰블
      - 이더넷 프레임의 시작을 알리는 비트열
      - 송수신간의 동기화를 위한 비트열
      - 첫 7바이트는 10101010, 마지막 1바이트는 10101011(SFD)
    - **목적지/송신지 MAC 주소**
      - 물리적 주소, 네트워크장치(NIC)마다 할당된 고유한 주소
      - 네트워크 세상의 주민등록번호!
      
      ```shell
      $ ifconfig
      ```
        - 해당 컴퓨터의 NIC(network interface card)에 할당되어 있는 데이터링크 계층의 물리적 주도체계인 MAC address확인 가능
        - ether xx:xx:xx:xx:xx:xx 라고 나온다.

> NIC(네트워크 인터페이스) <br>
: - 연결매체를 통해 받은 신호를 컴퓨터에게 전달 <br> - 네트워크에 연결하기 위한 하드웨어 <br> - 호스트가 네트워크에 연결되기 위한 하드웨어

  ![system_network_이더넷5.png](/assets/images/system_network_이더넷5.png)

    - 이더타입/길이
      - 1536 이상일 경우 : 이더타입(이 프레임이 무엇을 캡슐화 했는지를 나타냄)을 의미
      - 1536 이하일 경우 프레임 크기를 의미
      - [이더넷타입](https://www.iana.org/assignments/ieee-802-numbers/ieee-802-numbers.xhtml#ieee-802-numbers-1)

      | 이더타입 | 프로토콜 | 의미 | 
      | --- | --- | --- |
      | 0800 | IPv4 | 0800의 의미는 이 프레임은 IP버전 4를 캡슐화했음을 의미 |
      | 86DD | IPv6 |
      | 0806 | ARP | 


    - 페이로드  : 운반할 데이터를 의미
    - FCS
      - 오류 검출을 위한 CRC값이 명시되는 필드

### 2-2. 허브와 CSMA/CD

허브(hub)
  ![system_network_허브.png](/assets/images/system_network_허브.png)

    - 물리 계층의 장비
    - MAC주소를 사용하지 않는다(MAC주소는 데이터 링크 계층 개념)
    - 호스트를 연결할 수 있는 포트(port)
    - 주소 개념이 없기 때문에 모든 포트로 정보를 내보낼수 있음.(멀티탭같은거다.전원연결시 모든전원에 전원들어오자나) 왜냐하면, 물리계층에서는 주소의 개념이 없기 때문.


    - 전이중 통신(full-duplex)
      - 송신과 수신이 동시에 이루어지는 통신(ex.전화)


    - **반이중 통신(half-duplex)**
      - 송신 혹은 수신이 한 번에 한 번만 이루어지는 통신(ex.무전기), 즉, 송신할땐 송신만가능, 수신할땐 수신만 가능하다.

  ![system_network_허브2.png](/assets/images/system_network_허브2.png)

    - 동시에 허브로 데이터를 전송할 경우 충돌(collision)이 발생
    - 콜리전 도메인 : 충돌이 발생할수 있는 범위를 지칭

허브의 특성 정리
  - 전달 받은 신호를 모든 포트로 내보내고,
  - 연결된 모든 호스트가 충돌 도메인에 속해 있으며
  - 반이중 모드로 통신하는 물리 계층의 장비임.

반이중 이더넷의 충돌을 해결하기 위한 CSMA/CD
  1. CS : Carrier Sense
    - 캐리어(반송파)감지 : 메세지 전송 전 현재 전송 중인게 있는지 확인
  2. MA : Multiple Access
    - 다중접근 : 두 개 이상의 호스트가 동시에 네트워크에 접근 (충돌 발생)
  3. CD : Collision Detection
    - 충돌감지 : 잼 신호(jam singal)를 보낸 뒤, 임의의 시간 동안 대기 후 재전송

전달받은 신호를 목적지 포트로만 내보내고, 전이중 모드로 통신하는 데이터링크 계층의 네트워크 장비가 필요. 그게 `스위치`!

스위치
  - 전달받은 신호를 목적지 포트로만 내보내고,
  - 목적지 호스트가 연결된 곳만 충돌 도메인에 속해 있으며
  - 전이중 모드로 통신하는 데이터링크 계층의 장비이기에 MAC주소를 이해할수 있다.(mac address learning기능이 있다.)
  - 그래서 CSMA/CD가 필요하지 않다.
   
MAC주소 학습 기능

  ![system_network_스위치.png](/assets/images/system_network_스위치.png)
  
    - 포트에 연결된 호스트와 MAC주소의 관계를 기억하는 스위치 기능
      - 어떤 포트에 어떤 MAC주소를 갖고있는 호스트가 연결되어 있는지 맵핑관계를 학습하는 기능.
      - MAC주소 학습이 끝나면 스위치는 몇번포트에 어떤 포트,어떤 MAC주소가 연결되어 있는 호스트인지 모두 알수 있다.
      - 그로 인해, 특정 포트로만 데이터를 내보내고 받을수 있다.
    - MAC주소 테이블
    - 송신지 MAC주소를 기반으로 MAC주소 학습기능이 이루어진다.

    - MAC 주소 학습 과정
      1. 플러딩(flooding) : 허브와 같이 모든 포트에 프레임 전송
        - 스위치 입장에서는 MAC주소 테이블이 비어있는 상태이다.
        - 아직 MAC주소 학습하지 않았을때 모든 포트로 해당 프레임을 허브처럼 내보내는거
        - MAC주소 학습기능은 기본적으로 송신지 MAC주소 기반으로 이루어지기 때문에 이 과정에서 송신한놈의 MAC주소를 학습한다.
        - 그 후 플러딩을 하게 되면 거기에 목적지에 받는 호스트는 응답하고 나머지는 이걸 폐기하기 때문에 응답 호스트의 MAC주소를 학습할수 있다.

      2. 포워딩과 필터링 : 어떤 포트로 내보낼지 내보내지 않을지 결정. 맞는포트는 포워딩, 아닌포트는 필터링한다. 
      3. 에이징 : 특정시간이 지나면 MAC주소 테이블 항목 삭제

VLAN(Virtual LAN)이란
  물리적 위치에 관계없이 특정 LAN에 속할 수 있음

  - 스위치 기능
  - 가상의 LAN

  ![system_network_vlan.png](/assets/images/system_network_vlan.png)

  - 플러딩 통해 전달받아야 되는 메시지의 양이 많아질수 있음(호스트가 여러개 연결될수록)
  - 총무부,개발부가 같이 스위치에 물려있는데, 만약 개발부만 들어야될 공지사항을 브로드캐스트로 전송하게 되면 총무부도 함께 받게 된다.
    - 그래서 VLAN을 하면 가상의 LAN처럼 스위치에 연결되어 있는 호스트를 가상의 LAN으로 묶을수 있다. 그럼 당연하게도 브로드캐스트 범위도 달라지게 된다.
    - 그럼 개발부가 총무부에게 메세지 보내고싶다면? 그땐 네트워크 계층 이상의 장비가 필요.(Ex.라우터)
    - 왜냐하면 VLAN으로 나누면 아예 다른 LAN으로 간주하기 때문이다.
  
  - VLAN종류
    - 포트 기반 VLAN(정적 VLAN)
      ![system_network_vlan2.png](/assets/images/system_network_vlan2.png)

        - 특정 포트에다가 특정 VLAN을 할당하는것.
    - MAC 주소 기반 VLAN(동적 VLAN)
      ![system_network_vlan3.png](/assets/images/system_network_vlan3.png)
        - 포트에 상관없이 특정 MAC주소에 따라 VLAN을 구획해서 분류할수 있다.
        - 그러면 진짜 호스트의 물리적인 위치와 상관없이 가상의 LAN에 속해 있도록 할수 있다.



## 3. 네트워크 계층(WAN)

### 3-1. IP(Internet Protocol)
네트워크 계층
  - 물리 계층과 데이터링크 계층(MAC주소 기반)은 LAN에 국한된 계층이다.
  - LAN을 넘어서기 위한 계층으로는 네트워크 계층이 필요하다. 
  - 네트워크 간 통신이 가능한 계층을 위해선 `라우팅`이 가능해야 한다.
  - 단편화가 이루어지는 계층으로서 IP라는 protocol을 통해서 이루어진다.

> 라우팅 <br>
: 패킷을 목적지까지 최적의 경로로 찾아가는 과정을 의미 <br> - 라우팅을 가능하게 해주는 네트워크 계층의 장비가 라우터이다.

네트워크 간의 통신은 IP주소를 바탕으로 수행된다. 즉, IP주소를 바탕으로 네트워크 간의 통신이 가능해지고, 라우팅, 즉 최적의 경로로 목적지까지 찾아갈 수 있는것이다.

데이터 링크 계층의 MAC주소만으로는 네트워크 간의 통신은 어렵다.
  - 도달 경로를 파악하기 어려움(라우팅 어려움)
  - 임의의 네트워크에 속한 호스트의 MAC주소를 기억하기 어려움.
  - 모든 호스트들의 MAC주소를 하나의 컴퓨터가 알기 어렵다. 
  - ex)택배를 생각해라. MAC주소는 발신인/수신인 , IP주소는 발신주소/수신주소를 나타낸다.

기본적으로 MAC주소 이전에 **IP주소**를 사용
  - MAC주소 = 수취인 개인정보(ex.주민등록번호) -> 물리주소
  - IP주소 = 수취인 주소(ex.발신/수신 주소) -> 논리주소

|MAC주소 | 수취인 개인정보 | 주민등록번호 | 물리주소 | 직접할당 : NIC제작시 회사에서 직접만듬 | 
| IP주소 | 수취인 주소 | 서울시 노원구 xx번지 | 논리주소 | 자동할당 : DHCP라는 특정 프로토콜 이용하여 자동할당 |


IP의 기능
  - IP주소 지정(addressing)
  - 단편화(fragmentation)

[인터넷 표준문서](https://datatracker.ietf.org/doc/html/rfc791)

단편화 
  
  ![system_network_단편화.png](/assets/images/system_network_단편화.png)

    - 패킷의 크기를 MTU (Maximum Transmission Unit)이하로 유지
    - MTU 크기 이하로 단편화된 패킷들은 목적지에서 재조합

  ```shell
  > netsh interface ipv4 show interfaces
  $ ifconfig
  ```
    - MTU는 기본적으로 1500 size로 되어 있다.

    - MTU 작으면 전송률이 보장됨. 그러나 쪼개고 재조합하는 과정에서 오버헤드가 든다.
    - MTU 크면, 전송률이 보장되지만, 한번에 전송되는 데이터가 크기때문에 throughput에 문제가 생길수도 있다.

IPv4 헤더
  
  ![system_network_ipv4헤더.png](/assets/images/system_network_ipv4헤더.png)

    - 페이로드 : OSI 7계층으로 따지면 전송계층으로 부터 받은게 여기에 포함된다.
    - 송신지, 목적지 IP주소 : IP의 주요 기능중 주소지정기능에 사용된다.

  ![system_network_ipv4헤더3.png](/assets/images/system_network_ipv4헤더3.png)

    - 단편화에서 주로 사용되는 헤더(식별자, 플래그, 단편화오프셋)
      - 식별자 : 패킷에 할당된 번호 (재조합 시 사용) 
        - 해당 패킷들이 쪼개졌다가 재조합시 어떤 패킷에서 쪼개졌는지 알아야 하기 때문에 동일한 식별자 필요
      - 플래그 : 부가 정보(미사용, DF(Don't Fragment비트), MF(More Fragment 비트, 더 많은 단편화가 있다를 나타냄) )
      - 단편화 오프셋 : 단편화되기 전 데이터가 얼마나 떨어져 있는가
        - 해당 패킷이 시작점으로부터 얼마나 떨어져있는 패킷인지 알아야 한다.그래야 재조합시 올바른 순서대로 가능해짐.
      
    - TTL (Time To Live) : 패킷의 수명, 라우터를 거칠 때마다 1감소
      - 순환구조에 빠질때 TTL값이 0이되면 패기가능

    - 프로토콜 : 상위 계층의 프로토콜(ex.TCP == 6, UDP == 17)



  ![system_network_ipv4헤더2.png](/assets/images/system_network_ipv4헤더2.png)

    - 프레임페이로드에 IP 패킷 헤더가 포함된다.

  - IPv4주소
    - 4바이트(32비트)로 표현 가능
      - ex.192.198.0.0 : 점을 기준으로 4개의 숫자(=옥텟,octet)으로 표현
    - 한 옥텟은 0~255 범위의 네 개의 십진수로 표기
    - 이론적으로 할당 가능한 Ipv4주소개수 == 2^32개 <- IP주소 부족 문제 발생
    - IP주소 고갈문제 해결 : NAT
      - 공인IP를 사설 IP로 변환해주는 기술
    
  
  - IPv6주소
    ![system_network_ipv4헤더4.png](/assets/images/system_network_ipv4헤더4.png)
      - 16바이트(128비트)로 표현 가능
      - 이론적으로 할당 가능한 IPv6주소 개수 == 2^128개 <- 사실상 무한

    - (의외로) 더 단순한 헤더
      ![system_network_ipv6헤더.png](/assets/images/system_network_ipv6헤더.png)

        - 홉제한 = TTL, 패킷의 수명을 나타냄
        - 다음헤더 = 확장헤더(extension header), 기본적인 헤더는 고정되어 있지만 고정되지 않은 추가적인 헤더를 가질수 있다.
          - 다음헤더는 확장헤더를 가리키는 헤더이다.

    - 확장헤더

      ![system_network_ipv6헤더2.png](/assets/images/system_network_ipv6헤더2.png)

        - 위의 기본헤더에 상위계층 프로토콜헤더 or 확장헤더 or 확장헤더x2 가 붙을수 있다.
        - 확장헤더는 또다른 확장헤더를 가질수도 있다.(ex.확장헤더x2)
      
      - 단편화 확장헤더

        ![system_network_ipv6헤더3.png](/assets/images/system_network_ipv6헤더3.png)

          - 확장헤더는 또다른 확장헤더를 가질수 있기 때문에 다음헤더를 가리키는 필드를 가지고있고, 예약됨은 정해진 값이다.
          - 식별자, 플래그, 단편화 오프셋은 모두 IPv4헤더에 있던 필드들이다.

### 3-2. ARP

IP주소를 이용해서 MAC주소를 알아내기 위한 프로토콜. 단, **동일 네트워크 내의 호스트**의 MAC주소를 알아내기 위한 프로토콜이다.

ARP동작과정
  ARP요청과 응답시에는 ARP packet을 주고받는다.

  1. ARP요청(=브로드캐스트 메세지이다)
    - 특정 IP주소를  가진 호스트의 MAC주소를 알아내기 위해 보내는 브로드캐스트 메세지
    - 해당 호스트의 MAC주소를 모르기 때문에 브로드캐스트 메세지로 전송
  2. APR응답
    - ARP요청 메세지에 대한 응답. 자신의 MAC주소 포함.
    - ex) ARP요청에서 동일 네트워크 내에 모든 호스트에게 브로드캐스트 메세지로 전송시, ARP응답하는 호스트 하나가 자신의 MAC주소를 ARP응답 패킷에 포함시켜서 요청한 호스트에게 전송한다. 그러면 요청한 호스트는 응답한 호스트의 MAC주소를 알수있게 되고, 그렇게 A와 B는 서로 IP와 MAC주소를 아는사이가 된다.
  3. ARP테이블(ARP캐시) 갱신

    ![system_network_ARP패킷2.png](/assets/images/system_network_ARP패킷2.png)
      - ARP테이블(ARP캐시) : MAC주소와 IP주소가 매핑된 표 형태의 데이터
      - 일정 시간이 지나면 삭제
      - ARP테이블에 추가된 호스트는 브로드캐스트로 ARP요청 보낼 필요 없음.

    ```shell
    $ arp -a    // arp테이블 확인가능
    $ arp -ad    // arp테이블 전체 삭제
    $ man arp
    ```
      - IP주소와 MAC주소가 연결되어있음을 보여준다.

> ARP패킷
  
  ![system_network_ARP패킷.png](/assets/images/system_network_ARP패킷.png)

    - 프로토콜 주소는 IP주소, 하드웨어주소는 MAC주소를 말한다.
    - 오퍼레이션 코드에 따라서 ARP요청인지 응답인지 달라진다.
    - 만약 브로드캐스트를 할때는 목적지 MAC주소를 모르기 때문에 브로드캐스트를 위한 MAC주소가 정해져있다(ff:ff:ff:ff, 16진수로 보면 1111이므로 전부 1111로 세팅되어있다)


다른 네트워크에 속한 호스트의 MAC주소 알아내기
  - 라우터에게 기본적으로 패킷을 보낸다.
    - A호트스가 A라우터에게 패킷을 보내면 A라우터는 자신의 Ip주소와 MAC주소를 알려줄것이다. 그러면 A호스트는 자신의 ARP테이블에 IP주소와 MAC주소를 추가할것이다.
    - 라우터 A는 라우터B에게 패킷을 보내서 알아낸다.
    - 라우터 B는 자신의 동일 네트워크에 있는 호스트B에게 패킷보내서 IP주소와 MAC주소를 알아낸다.
    - 이로써 A호스트는 B호스트에게 패킷이 전달이 될것이다.
    - 라우터끼리의 전달에는 라우팅프로토콜이 관여한다. 현재는 ARP만 고려해서 보았다.

### 3-3. ICMP

`IP의 한계` 때문에 ICMP이 등장했다. 
IP의 한계 2종류
  1. 비신뢰성 전달을 한다.(=best-effort delivery, 최선형전달)
    - 패킷이 목적지까지 제대로 전송한다는 보장이 없는 특성
    - IP를 이용해서 단편화와 주소지정을 할수 있는데, 주소지정을해서 무언가를 보냈는데 그게 반드시 제대로 전송된다는 보장이 없는거다.
  2. 비연결형 전달을 한다.
    - 호스트 간의 사전 연결 수립이 없는 특성
    - 회선교환 네트워크를 보면 호스트끼리 연결작업을 먼저 했다. 그래서 회선연결후 연결된 회선끼리만 통신을 주고받았다. 이렇게 호스트 간의 사전 연결수립이 없는 특성을 비연결형 특성이라 한다.즉, 사전준비를 거치지 않은 상황에서도 전달이 되는 특성을 말한다.

이러한 IP의 한계를 극복할수 있는 계층이 네트워크 계층 위에 있는 전송계층(TCP)이다!

전송계층은 신뢰성 프로토콜, 연결형 프로토콜을 제공함으로써 IP의 한계를 극복한다.

ICMP
  - [ICMP 공식문서](https://www.rfc-editor.org/rfc/rfc792)
  - 네트워크의 진단정보에 대한 메시지를 얻기위해서 ICMP 프로토콜이 이용된다.
  - IP의 비신뢰성과 비연결형 특성을 보완하기 위한 네트워크 계층 프로토콜
  - IP패킷의 전송 과정에 대한 `피드백 메세지` 제공
    - 오류보고
        
        ![system_network_ICMP2.png](/assets/images/system_network_ICMP2.png)

          - 특정 패킷을 목적지까지 도달할 수 없음 = ICMP는 Destination Unreachable 이라는 메시지를 뿌림.

    - 네트워크 진단 정보

      | 타입이름(타입번호) | 코드번호 | 코드설명 | 
      | --- | --- | --- |
      | 에코요청(8) | 0 | 에코 요청 |
      | 에코 응답(0) | 0 | 에코 요청에 대한 응답 | 
      | 라우터 광고(9) | 0 | 라우터 광고; 라우터가 호스트에게 자신을 알림 |


      ![system_network_ICMP3.png](/assets/images/system_network_ICMP3.png)
        - echo는 메아리의미이기에 내가보내면 그에 응답해줘 라는 의미이다.

        ```shell
        $ ping -c 5 www.google.com
        $ traceroute www.google.com
        ```
          - 이렇게 Ping이란 명령어도 ICMP 프로토콜을 이용한다.
          - traceroute : 해당 네트워크까지 도달하기 위한 전체 경로가 출력됨
            - 이 과정에 사용되는 메세지도 ICMP 이다.


  - ICMP패킷
    ![system_network_ICMP.png](/assets/images/system_network_ICMP.png)

      - ICMP 메시지는 타입과 코드로 정의. 즉, ICMP가 어떤 메시지를 전달하는지는 타입과 코드로 정의가능.
      - 오류보고에 대한 타입과 예시(Destination Unreachable 이라는 메세지를 뿌리는것도 ICMP이다.)

  - ICMP는 IP의 한계를 보완할 뿐 완전히 해결하는 것은 아니다. 근본적 해결은 전송계층의 TCP 프로토콜을 이용해서 이루어진다.



### 3-4. IP주소

IP주소의 구성요소 2가지 : 
    - 네트워크 주소
    - 호스트 주소

  ![system_network_IP주소.png](/assets/images/system_network_IP주소.png)
    - 네트워크주소와 호스트 주소는 유동적이다. 즉, 네트워크주소를 1개의 octet, 호스트주소를 3개의 octet으로 정할수도 있다.

전통적으로는 클래스풀 주소체계를 통해 네트워크주소와 호스트주소를 구분지었다.

> 클래스풀 주소체계 <br>
: class라는 개념을 바탕으로 네트워크 부분과 호스트 부분을 나누어서 관리하겠다는 개념.

  - A class : 하나의 octet으로 네트워크 주소 나타내고, 3개의 octet으로 호스트 주소를 할당
    - B,C class에 비해서 A class는 더 많은 호스트를 할당할수 있다.
    - A class는 네트워크주소의 첫번째 bit를 0으로 시작한다.
    - 0.0.0.0 ~ 127.255.255.255 가 IP주소 범위이다.
  - B class : 2개의 octet으로 네트워크 주소를 나타내고, 2개의 octet으로 호스트 주소를 할당.
    - 네트워크 주소가 10 bit로 시작한다.
    - 128.0.0.0 ~ 191.255.255.255 가 IP주소 범위이다.
  - C class : 3개의 octet으로 네트워크 주소를 나타내고, 1개의 octet으로 호스트 주소를 할당.
    - 네트워크 주소가 110 bit로 시작한다.
    - 192.0.0.0 ~ 223.255.255.255 가 IP주소 범위이다.
  
  - 위 주소 체계에서 2가지 주소는 미리 약속이 되어 있기에 모든 범위에서 2개는 빼야한다.
    - 네트워크 주소 : 호스트 주소부가 모두 0 인경우
    - 브로드캐스트 주소 : 호스트 주소부가 모두 1인 경우

클래스리스 주소체계
  - 클래스풀 주소 체계보다 더 정교히 네트워크를 나누는 방법
  - 전통적인 클래스풀 주소체계보다 IP주소 낭비를 아낄수 있다.
  - 오늘날 주로 사용하는 방식
  - 네트워크와 호스트를 구분하기 위해 `서브넷 마스크` 이용

> 서브넷 마스크 <br>
  - IP주소 상에서 네트워크 주소는 1, 호스트 주소는 0 으로 이루어진 비트열
  - 예시)
    - 클래스 A : 255.0.0.0 (11111111.00000000.00000000.00000000)
    - 클래스 B : 255.255.0.0 (11111111.11111111.00000000.00000000)
    - 클래스 C : 255.255.255.0 (11111111.11111111.11111111.00000000)

서브넷 마스크와 IP주소의 비트 AND연산을 이용하여 네트워크 주소를 표현한다.

  ![system_network_IP주소2.png](/assets/images/system_network_IP주소2.png)

    - 서브넷마스크에서 빨간색부분이 네트워크이고, 파란색부분은 호스트이다.
    - IP주소를 보고 네트워크와 호스트부분을 판단하기 위해 이진수로 변환해보자.

  [ip to binary converter](https://www.browserling.com/tools/ip-to-bin) 를 이용하여 ip를 binary로 쉽게 변환가능.

  ![system_network_IP주소3.png](/assets/images/system_network_IP주소3.png)

    - 이렇게 AND연산하면 그 결과가 네트워크 주소(192.168.219.0)가 된다.

CIDR(사이다)표기
  - 서브넷 마스크 상의 1의 개수를 `IP주소/숫자`로 표기
  - ex) 192.168.100.103/30
    - 서브넷 마스크가(11111111.11111111.11111111.11111100) 로 표기. 즉 1의 개수가 30개인경우다.

    ![system_network_IP주소4.png](/assets/images/system_network_IP주소4.png)

      - [IP subnet계산](www.calculator.net/ip-subnet-calculator.html)
        - 192.168.100.103/30 일때의 IP address
        - 할당가능한 host ip의 주소 범위는 호스트 주소부분이 전부다 0일경우와 1일경우는 각각 네트워크주소와 브로드캐스트 주소니깐 뺴야하므로 딱 2개만 할당가능
        - 이론적으로 할당가능한건 4개. 실제할당가능한건 2개가 나온다.
        - 192.168.100.103/27인 경우에도 IP address ~ subnet mask까지는 해석해야한다.

### 3-5. IP주소의 분류

공인IP주소 : 인터넷 사용할때 사용하는 고유한 주소
  - 한국인터넷진흥원(KRNIC)이 국내 IP주소를 ISP(인터넷서비스제공자)에게 할당하고, ISP는 다시 사용자에게 IP주소를 할당함.
  - 통신사업자(KT,SKB,LGU+)가 관리대행자가 되어 진흥원으로부터 직접 할당받는 방법
  - 직접 KRNIC로부터 IP를 직접 할당받는 방법
사설IP주소 : 사설 네트워크 내에서 사용하는 고유하지 않은 주소, 일반적으로 LAN에서 사용되는 IP는 사설IP이다.
  - 사설 IP주소 대역
    - 10.0.0.0/8
    - 127.16.0.0/12
    - 192.168.0.0/16

    - 예약된 IP주소
      ![system_network_IP주소5.png](/assets/images/system_network_IP주소5.png)

NAT(나트) : 공인IP주소와 사설 IP주소간의 변환 가능

  ![system_network_IP주소6.png](/assets/images/system_network_IP주소6.png)
  
    - Ex) 공유기
    - 하나의 공인 IP주소를 여러 사실 IP주소가 공유가능(PORT이용하여 가능)
    - IP주소 부족 문제 해결
 
정적IP주소와 동적IP주소
  - IP주소의 할당방법 : 정적할당과 동적할당
  - 정적IP주소 : 정적 할당된 IP주소(고정)
    - 게이트웨이 or router : 내가 네트워크 밖으로 패킷을 내보낼때 가장 처음으로 거쳐야 되는 호스트
    
```shell
$ nmtui
```
  - linux환경에서 정적IP설정

  - 동적IP주소 : 동적 할당된 IP주소(유동적)
    - DHCP(일반적으로 공유기 or 라우터안에 들어있다.)
      - 동적 IP주소를 할당하기 위한 프로토콜
      - DHCP 서버에 의해 동적으로 IP주소 할당(==IP주소 임대)
      - DHCP는 자동으로 할당해줄수 있는 IP주소의 풀관리하고 있다. 이는 보통 공유기 or 라우터가 제공해주는 기능이다.
      - 정해진 임대 시간이 끝날 경우 임대 갱신(자동수행, 수동수행)

호스트가 DHCP서버로부터 어떻게 동적으로 IP주소를 할당받는가?

  ![system_network_IP주소7.png](/assets/images/system_network_IP주소7.png)

    - 총 4단계로 이루어짐
    - discover : ip하나 빌려줘 라고 브로드캐스트 메시지를 보내는것.왜냐하면 DHCP는 여러개 있을수 있거든.
    - offer : DHCP가 ip빌려줄수있어 라고 답변해주는것.
    - request : 호스트가 그 답변듣고 나 이거 이제 사용할래! 라고 실제 요청하는 패킷이다.
    - acknowledgement : 해당 IP를 할당해주는것.

### 3-6. 라우팅

네트워크 계층 장비, 라우터  
  - 라우팅 : 패킷이 이동할 최적 경로 설정, 해당 경로로 패킷 이동
  - 라우팅 프로토콜 : 라우팅을 수행하는 방법
  - 홉 : 라우터와 라우터 간의 패킷 이동 과정
  - 홉 바이 홉 라우팅 : 여러개의 라우터를 깡총깡총 건너듯이 패킷을 전달하면서 최종적인 호스트까지 패킷을 전달하는 라우팅과정
    - 어떤 라우터한테 패킷을 전달해야지 최적의 경로인지 항상 결정할수 있어야 한다.

    ![system_network_라우터.png](/assets/images/system_network_라우터.png)

    ```shell
    $ traceroute google.com
    ```

      - 내 패킷이 어떤 라우터를 거치면서 최종적인 목적지 호스트로 도달했는지를 볼수가 있다.
       
  - **디폴트 게이트웨이** : 같은 네트워크 즉 사설 네트워크 같은 랜에 속해 있는 호스트가 이제 가장 먼저 인터넷에 뻗어나가기 위해 거쳐야 되는 라우터
  - **게이트웨이** : 라우터와라우터끼리 패킷을 주고받을때 다음 라우터를 게이트웨이라고 한다. 쉽게 다음 홉이라고 생각하면 된다.

이러한 라우터는 어떻게 최종목적지까지 패킷을 전달할수 있는가?

라우팅 테이블
  - 특정 목적지까지 도달하기 위한 정보를 명시하는 표와 같은 정보
  - 대표적인 정보 : 목적지 주소, 서브넷 마스크, 게이트 웨이, 인터페이스, 메트릭
    - ex)
  
      | No | 목적지 주소 | 서브넷 마스크 | 게이트 웨이 | 인터페이스 | 메트릭 |
      | --- | --- | --- | --- | --- | --- |
      | 1 | 192.168.2.0 | 255.255.255.0 | 192.168.2.1 | eth0 | 30 |
      | 2 | 192.168.2.16 | 255.255.255.240 | 192.168.2.1 | eth0 | 30 | 11000000.10101000.00000010.0010000 |
      | 3 | 192.168.0.0 | 255.255.0.0 | 192.168.2.1 | eth1 | 30 | 11000000.10101000.00000000.00000000 |

        - 목적지주소,서브넷마스크를 통해 어디로 보낼지를 알고,
        - 게이트웨이는 다음 홉은 어디인지 말해준다.
        - eht0이라는 인터페이스로 패킷을 내보내란 의미
        - 메트릭 : 다양한 경로중 해당 경로를 선택할때의 비용을 의미(비용은 낮을수록 좋은거다)
    - 라우터는 위와 같은 표를 바탕으로 최종 목적지까지 어떤 패킷을 전달해야 되는데 다음 홉은 어디고, 다음 홉으로 가기위해서 어떤 인터페이스로 패킷을 내보내야되고 그때 경로는 어느정도 비용이소모되는 등의 정보를 갖고 어디로 패킷을 내보낼지 결정을 하게 된다.
  
  - 롱기스트 프리픽스 매치(longest prefix match)
    - 여러 라우팅 테이블 항목과 일치할 경우 가장 길게 일치하는 항목 선택 후 패킷 전송
    - 192.168.2.20으로 패킷을 전달해야 할때(목적지 주소임) no2, no3이 합치가된다.(서브넷마스크를 계산해보면 그렇게 나온다) 이때 결과적으로 eth 0이나 eth 1로 내보낼지 결정필요할때 192.168.2.20을 2진수로 나타내면 11000000.10101000.00000010.00010100 이된다.
      - 해당 항목과 가장 많이 일치하는것은 no2가 된다. 그래서 no2로 패킷을 내보내게 된다.
  
  - 디폴트 라우트(defalut route)
    - 합치되는 경로가 없을 경우 기본으로 내보낼 경로(0.0.0.0/0)로 보내게 된다.
  
  ```shell
  $ route -v
  $ netstat -rn 
  ```
    - 라우팅 테이블(routing table)조회하기

라우팅 테이블이 만들어지는 방법

  ![system_network_라우팅프로토콜.png](/assets/images/system_network_라우팅프로토콜.png)
    
    - 정적 라우팅 : 수동으로 라우팅 테이블 항목 채워넣기 
      - 단점 : 경로우회 x, 해당 라우터 고장시..패킷이 최종까지 못간다.
    - 동적 라우팅 : 자동으로 라우팅 테이블 항목 채워넣기(이것을 채워넣는 프로토콜이 라우팅 프로토콜이다)
      - 경로 우회 가능

    - 라우팅 프로토콜
      
      - AS 내부 라우팅 프로토콜(IGP, interior gateway protocol) : RIP, OSPF
        - RIP : 거리벡터사용
        - OSPF : 링크상태활용, 현재 라우터와 라우터를 연결짓는 링크의 전체 그림을 (라우터 가능한 링크의 전체 그림을) 링크 상태가 변경될 때마다 지속적으로 업데이트하면서 전체 그림을 유지하면서 라우팅하는 방식
      - AS 외부 라우팅 프로토콜(EGP, exterior gateway protocol) : BGP
      * AS == 동일한 라우팅 정책으로 운영되는 라우터들의 집단 네트워크
        - 하나의 집단이더라도, 하나의 라우팅을 쓰진 않을것이다.
        - 라우터 집단을 ASxxxx로 관리한다는 예시
          - [예시) AS번호 사용자 현황](https://xn--3e0bx5euxnjje69i70af08bea817g.xn--3e0b707e/jsp/business/management/asList.jsp)

      


## 4. 전송계층
TCP와 UDP

전송계층의 역할
  - 전송계층은 네트워크계층 위에, 응용계층아래에 있다.
    - 전송계층은 네트워크계층의 IP 프로토콜의 한계극복계층이자, 응용계층의 어플리케이션 프로세스 식별하는 계층이다.
    - 응용계층에는 많은 프로그램이 실행되어있을수 있다. 한글,엑셀,게임 등등, 이런것을 식별해주는게 전송계층이다.식별은 포트로한다.
  - 응용계층의 어플리케이션 프로세스 식별 : `포트`로 한다
  - 네트워크 계층의 신뢰성/연결성 확립

### 4-1.포트

  - 네트워크 계층은 IP주소 토대로, 해당 호스트가 누구인지까지 식별가능,즉 A호스트에서 B호스트까지 네트워크계층이 전달해준다.
  - 이후 B호스트에 패킷이 도달후 해당 패킷을 B호스트의 어떤 프로세스에게 전달할지는 포트를 이용해서 전송계층에서 담당한다.

  - 포트번호는 16비트로 표현가능(65536개)
  - 포트범위 : 0 ~ 65535번까지

  | 포트종류 | 포트 번호 범위 |
  | --- | --- |
  | 잘 알려진 포트 (well known port) | 0 ~1023 |
  | 등록된 포트 (registered port) | 1024 ~49151 |
  | 동적 포트 (dynamic port) | 49152 ~ 65535 |

  - [예시 : 등록된 포트](https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xhtml)

  -  잘 알려진 포트(= well known port, 시스템포트)
    |포트 번호 | 설명 |
    | --- | --- |
    | 20,21 | FTP,파일전송 위한 프로토콜 |
    | 22 | SSH, 안전하게 정보를 주고받기 위한 프로토콜 |
    | 25 | SMTP, 이메일 주고받기 위한 프로토콜 |
    | 53 | DNS(Domain Name Server) |
    | 67, 68 | DHCP |
    | 80 | HTTP |
    | 443 | HTTPS |

  - 등록된 포트 : 잘 알려진 포트에 비해서는 덜 범용적이지만 흔히 사용되는 애플리케이션

    | 포트번호 | 설명 |
    | 1194 | OpenVPN |
    | 1433 | Microsoft SQL Server 데이터베이스 | 
    | 3306 | MySQL 데이터베이스 |
    | 6379 | Redis |
    | 8080 | HTTP 대체 |
      
전송계층
  - 서버 : 일반적으로 **잘 알려진 포트와 등록된 포트**로 동작.
  - 클라이언트 : 일반적으로 **동적포트**로 동작

    ![system_network_전송계층.png](/assets/images/system_network_전송계층.png)
  
  - 리소스모니터 > 네트워크 > TCP연결 에서 포트확인가능.
  
    ![system_network_전송계층2.png](/assets/images/system_network_전송계층2.png)

      - 로컬주소와 로컬포트를 할당받아서 실행하고 있는 프로세스는 크롬브라우저이다.
        - 해당 크롬브라우저는 원격주소+원격포트와 정보를 주고받고있음을 확인할수 있다.

- 사용 예
  - NAT : 공인 IP주소와 사설 IP주소 간의 변환가능
    - 하나의 공인 IP 주소를 여러 사설 IP주소가 공유 가능 <- 여기서 `포트`사용
    - IP 주소 부족 문제 해결
    - 예) 같은 공인 IP주소를 공유하되, 포트번호만 다르게 하면 공인IP주소를 다르게 사용가능. 

      ![system_network_전송계층3.png](/assets/images/system_network_전송계층3.png)

        - 네트워크 내부 : 사설IP라고 가정했을때, 192.168.0.5 가 외부의 10.11.12.13와 통신을 할때
        - NAT기능을 제공하는 공유기를 거쳐서 공인IP주소가 변환이 된다.
        - 이때, 192.168.0.5:1025 포트번호로 실행중인 어플리케이션이 나갈때는 1.2.3.4:6200번으로 나가게 된다.
         
포트조회시 리눅스에서 사용되는 명령어

  ```shell
  $ sudo apt install net-tools -y
  $ netstat   // 사용중인 포트결과가 나온다.
  $ netstat -n  // port number가 확인된다.
  $ netstat -t  // tcp만 확인가능
  $ netstat -nt // port number및 tcp만 확인가능
  $ netstat -u  // udp만 확인가능
  $ netstat -r  // routing table 확인가능
  $ netstat -a  // socket종류 모두 출력
  $ netstat -p  // process PID 출력
  $ netstat -i  // interface table 확인가능
  $ ss -tnp // ss도 netstat과 같은역할이다.
  ```
    - local address: 나의 호스트 이름
    - foreign address : 원격지의 주소
    - state : 현재상태(established:연결수립성공)

### 4-2. TCP와 UDP

MSS(maximum segment size) : TCP세그먼트로 보낼 수 있는 최대 크기
  ![system_network_TCP.png](/assets/images/system_network_TCP.png)
    - 전송계층으로부터 캡슐하는 데이터가 위에 그림만큼 있다면 MTU의 크기는 헤더까지도 포함하는 정보이다.
    - 그렇기 때문에 IPMTU의 경우는 저만큼 되어있다.
    - 그러나, MSS는 헤더크기는 산정하지 않는다.즉, 페이로드 크기 = MSS 크기가 된다.

TCP 세그먼트 구조
  
  ![system_network_TCP2.png](/assets/images/system_network_TCP2.png)

    - 출발지포트 / 목적지 포트 : 어플리케이션 프로세스를 식별할수 있는 고유한 번호
          - 전송계층의 역할이 출발지포트와 목적지포트를 식별해주는 역할이기 때문에 TCP세그먼트는 출발지 포트와 목적지 포트에 정보가 있어야 한다.   
    - TCP는 재전송을 통한 오류 제어기능,흐름제어 등 다양한 기능 제공
    - 제어비트
      - ACK: 세그먼트 승인을 나타내는 비트
      - SYN : 연결 수립을 위한 비트
      - FIN : 연결을 끝내기 위한 비트
      - RST : 연결을 리셋하기 위한 비트
      - TCP는 연결형 프로토콜 이기 때문에 SYN, FIN 같은 비트가 필요하다.
    - **순서 번호(sequence number)** : 송수신되는 세그먼트 데이터 첫 바이트에 부여되는 번호

      ![system_network_TCP3.png](/assets/images/system_network_TCP3.png)

        - 어플리케이션계층으로 부터 1900 바이트를 받았지만, 보낼수 있는 크기는 정해져 있다(Ex.MSS) 
          - 즉, 500바이트씩 끊어서 보낸다고 가정한다면, 초기 순서번호를 랜덤한 값으로 매기게 된다.
          - 이 세그먼트를 식별할수 있는 번호로서 해당 세그먼트에다가 순서번호를 매기는게 순서번호의 개념이다.
          - 즉, 데이터 전체에다가 초기 순서번호를 랜덤한 값으로 넣는다(초기100 이면, 다음 세그먼트B에는 600, 다음 세그먼트 C에는 1100이 초기 순서번호로 들어간다.)

    - **확인 응답 번호(acknowledgement number = ack number)** : 순서 번호에 대한 응답(다음으로 수신받길 기대하는 바이트 번호)
    - 윈도우 : 흐름제어때 사용될 윈도우 크기, 한번에 수신 받고자 하는 양(흐름제어에서 언급)
    
UDP 데이터그램  
  
  ![system_network_TCP4.png](/assets/images/system_network_TCP4.png)

    - UDP는 IP패킷을 감싸는 껍데기일뿐.
    - 비연결성/비신뢰성 프로토콜
    - TCP의 재전송/흐름제어/혼잡제어 등의 기능 없음.
    - 체크섬 : 수신되 데이터의 오류가 있는지 판단하는 필드
      - 체크섬 필드는 신뢰성과는 관련이 없다.
      - 즉, 상대방으로부터 데이터그램을 잘 수신받았다면 받은데이터에 대해 오류가 없는지를 확인. 내가 어떤거를 잘 받았다는 잘 받을거라는 보장이 있는 필드는 아님.
      - 체크섬필드는 신뢰성과 관련이 없으며,송수신이 됬다는 전제하에 오류가 있는지만 검출하는 필드이다.

* TCP는 하나하나 확실히 던지며, UDP는 빠르게 마구던지는 역할이다.

  ![system_network_TCP5.png](/assets/images/system_network_TCP5.png)

    - UDP는 보내면서 순서가 바뀔수도 있으며, 패킷유실이 발생할수도 있다.
    - UDP는 TCP에 비해, 사전 연결수립작업이 없기에 굉장히 빠른 성능을 내기에 최근에 각광받는 프로토콜이다.
      - HTTP/3, NTP, RIP, DNS, DHCP

### 4-3. TCP 연결

TCP는 연결형 프로토콜
  
  1. 연결 설정  <- Three-way handshake

    ![system_network_TCP6.png](/assets/images/system_network_TCP6.png)

      - SYN 세그먼트 : SYN bit가 1로 초기화된 segment를 보내면서 자신의 순서번호를 알려준다.
      - SYN + ACK 세그먼트 : 만약 연결요청을 수락할 의사가 있다면 segment의 SYN bit와 ACK bit둘다 1로 세팅된 segment를 보내주게 된다. 이때 이 세그먼트에 대한 확인응답번호가 있고, 그리고 자신의 순서번호도 호스트A에게 알려주게 된다.
      - ACK 세그먼트 : 이제 진짜 연결시작하겠다라는 알림을 내포하고 있다. 여기엔 호스트B가 보낸 초기 순서번호에 대한 응답번호가 포함되어 있다.

    - Active Open host : 연결을 처음에 시작하려고 하는 호스트
    - Passive Open host : 연결요청을 수락하는 역할(ex.대부분의 역할은 서버가 한다.)


  2. 데이터 송수신
  3. 연결종료

    ![system_network_TCP7.png](/assets/images/system_network_TCP7.png)

      - Active close host : 처음 연결 종료를 요청하는 호스트
      - Passive close host : 연결종료요청을 받아들이는 호스트
      - FIN과 ACK 세그먼트를 한번씩 주고받으면서 연결종료가 된다.
      - host B는 처음 FIN 세그먼트를 받으면 어느정도 대기 타다가 "이제 연결 끊어요"라고 FIN segment를 보낸다.
      - HOST A는 마지막 ACK segment를 보낸다음에 어느정도 시간이 지난다음에 연결종료가되고, 호스트 B는 받자마자 바로 종료된다.
        - 왜냐하면? active clost host는 마지막 ACK를 보낸 뒤 `일정 시간을 기다리고` 연결을 종료한다. 
          - 마지막 ACK segment의 유실대비 위해.
          - 또 다른 연결 과정에서의 패킷 혼선 방지 위해.


TCP는 연결형 프로토콜 + 스테이트풀(stateful) 프로토콜 
  - 현재 연결 상태를 나타내기 위해 다양한 상태(state)활용

  * UDP는 상태를 유지하지 않는 stateless protocol이다.


  ```shell
  $ ss tan | head -5  // 내가 만든 서버의 현재 상태값 확인 
  ```

TCP의 가능한 상태 목록

  ![system_network_TCP8.png](/assets/images/system_network_TCP8.png)
    
    - CLOSED : 어떤연결도 되지 않은 상태
    - LISTEN  : 연결수립과정에 사용 , SYN 세그먼트를 기다리는 상태(서버호스트는 항상 LISTEN상태를 유지한다.)
    - SYN-SENT : 연결수립과정에 사용,  SYN 세그먼트를 보낸 뒤 SYN+ACK 세그먼트 대기상태
    - SYN-RECEIVED : 연결수립과정에 사용, SYN+ACK 세그먼트를 보낸 뒤 그에 대한 ACK대기상태
    - ESTABLISHED : 현재 송수신이 가능한 상태
      - Three-way handshake 끝났을 경우
      - 데이터 송수신 가능

  ![system_network_TCP9.png](/assets/images/system_network_TCP9.png)

    - FIN-WAIT-1  : 연결 종료때 사용되는 상태, 먼저 종료 요청을 하는 호스트가 active clost host이다.이 host가 fin 세그먼트 보내면, FIN-WAIT 1상태로 전환된다. 
    - FIN-WAIT-2 : 연결 종료때 사용되는 상태
    - CLOSE-WAIT : 연결 종료때 사용되는 상태 , 호스트b입장에서 ACK 세그먼트 보내고, 다음 FIN 세그먼트 보내기 전깢 상태가 CLOSE-WAIT상태이다.
    - CLOSING : 연결 종료때 사용되는 상태  
      - 상대 FIN 세그먼트에 ACK 세그먼트를 보냈지만 자신의 FIN 세그먼트에 대한 ACK 세그먼트를 받지 못한상태(보통 동시에 연결을 종료하려 할때)
    - LAST-ACK : 연결 종료때 사용되는 상태
    - TIME-WAIT : 연결 종료때 사용되는 상태, 일정시간 동안 기다린 다음에 연결을 종료하는 상태 
      - 마지막 ACK세그먼트의 유실 대비
      - 또 다른 연결 과정에서의 패킷 혼선 방지


TCP상태 확인

  ![system_network_TCP10.png](/assets/images/system_network_TCP10.png)

### 4-4. TCP재전송 기능

TCP는 신뢰성 프로토콜이다.
  - 무엇인가를 확실히 전송했다는 보장이 있으려면?
    1. 재전송 기반의 오류 제어 : 잘못 전송된 경우 재전송
    2. 흐름제어 : 받을 수 있을 만큼만 받기
    3. 혼잡제어 : 보낼 수 있는 상황에서만 보내기

언제 잘못 되었음을 TCP는 인지할까?
  1. 중복된 ACK 세그먼트를 수신했을때

    ! [system_network_TCP11.png](/assets/images/system_network_TCP11.png)

  2. 타임아웃이 발생했을때.
    ! [system_network_TCP12.png](/assets/images/system_network_TCP12.png)
      
      - 타임아웃의 타이머는 재전송 타이머를 말한다.
      - 세그먼트 보낼때 타이머가 일정시간 지나면 타임아웃이라는 이벤트 발생시킨다.

      - n+1번 세그먼트 받아라고 보내고 나서 재전송타이머가 시작이된다. 그러다 일정 시간이 지나면 타임아웃 이벤트가 발생한다. 타임아웃이벤트 발생전까지 ACK 세그먼트를 받지 못한다면 문제가 생긴거다.

TCP 오류 제어
  - TCP는 재전송 기반의 오류 제어를 수행
  - 재전송을 기반으로 잘못된 전송을 바로잡는 것 : ARQ( 자동 재전송 요구 )

ARQ 
  : 이중 Stop-and-Wait ARQ는 사용안하고 나머지 2개를 혼용해서 TCP에서 사용한다.
  - Stop-and-Wait ARQ
    ![system_network_TCP13.png](/assets/images/system_network_TCP13.png)

      - 가장 단순한 형태
      - 제대로 보냈음을 확인하기 전까지는 보내지 않음
      - 전송하고, 확인하고, 전송하고, 확인하고,..만약 전송확인안되면 재전송하고 확인하고..
        - n+2번 ACK 세그먼트를 못받았기에 n+2번 세그먼트가 준비되었더라도 보내지 않는방법이다.
      - 단점) 네트워크 이용 효율이 낮아지는 문제
        - n+2, n+3번 세그먼트가 준비되엇더라도 보내지 못하게 된다.

      - 이런 문제를 해결하려면? 여러 세그먼트 한번에 전송(== `파이프라이닝`)
        ![system_network_TCP14.png](/assets/images/system_network_TCP14.png)

          - 확인응답받기 전이라도, 네트워크 양의 max를 한번에 혹은 연속적으로 보내는 방식
  - Go-Back-N ARQ

    ![system_network_TCP15.png](/assets/images/system_network_TCP15.png)
      
      - 올바른 세그먼트에 대해서는 확인 응답 보냄
      - 올바르지 않은 세그먼트(ex. N번 세그먼트)가 수신되면 이후(N+1번 이후) 모든 세그먼트 폐기
        - 호스트A입장에서는 N+2번째 ACK세그먼트를 못받았으니 이후 부터 타임아웃이 된다.그래서 자연스럽게 재전송이 되게 된다.
      - 누적 확인응답방식이다(Cumulative ACK, CACK)

  - Selective Repeat ARQ
    
    ![system_network_TCP16.png](/assets/images/system_network_TCP16.png)
      
      - 올바른 세그먼트에 대해서만 확인 응답 보냄
      - 각 세그먼트에 대한 확인 응답 : 개별 확인 응답
      - 호스트A입장(보내는쪽 입장)에서 내가 지금까지 보낸것중 확인응답 못받은 세그먼트를 직접 확인후 정렬해서 다시 보내는 역할이 추가된다.

  * 빠른 재전송(fast retransmit)

    ![system_network_TCP17.png](/assets/images/system_network_TCP17.png)

      - 빠른 재전송이 있는 경우 : 재전송 타이머가 만료되지 않아도 (일반적으로 3번의) 중복 세그먼트가 수신되면 재전송
      - 빠른 재전송이 없는 경우 : 재전송 타이머가 만료되어야 비로소 재전송


### 4-5. TCP의 혼잡제어와 흐름제어

TCP흐름제어
  - 송신버퍼 : 어플리케이션 계층에서 전송할 데이터 임시 저장
  - 수신버퍼 : 네트워크 계층에서 수신할 데이터 임시 저장
  - 보낼수 있는 양과 받는 양에 대해선 버퍼크기만큼 한계가 지정된다.
  
송신 호스트가 수신 호스트가 처리할 수 있는 수신 버퍼보다 더 많은 데이터를 전송하면? `버퍼오버플로우`: 일부 데이터가 처리되지 않을수 있음.

송신 호스트가 수신호스트 처리 속도를 고려하며 송수신 속도를 균일하게 맞춰야 함.
(수신호스트 입장에서 얼만큼 수신할수 있을지를 송신호스트가 인지해서 균일하게 전송하는게 흐름제어이다.)

즉, 수신호스트는 내가 얼만큼 수용할수 있을지를 TCP header를 통해서 알려주게 되고 TCP segment 필드에 있는 `window크기`필드를 통해 손신호스트에게 알려준다.


오늘날 TCP에서의 흐름 제어는 `슬라이딩 윈도우(sliding windows)` 이다.

  - 윈도우 : 파이프라이닝 가능한 순서번호 범위
  - 윈도우 크기 : 확인 응답 받지 않고도 한번에 보낼 수 있는 최대 양

    ![system_network_TCP18.png](/assets/images/system_network_TCP18.png)
      
      - (수신) 윈도우 크기 : TCP헤더를 통해 송신지에게 알려주는 정보
        - 윈도우 크기는 수신지를 기준으로 정한다.
      - 세그먼트의 ACK신호를 받으면 한칸씩 슬라이딩하여 옮긴다.
      - 아래의 수식을 유지한다.
        - 수신호스트
          - 수신윈도우 = 수신버퍼크기 - [마지막으로 수신한 바이트 - 마지막으로 읽어들인 바이트]
        - 송신호스트
          - 수신윈도우 >= 마지막으로 송신한 바이트 - 마지막으로 수신 확인된 바이트

TCP혼잡제어
  - 혼잡(congestion)
  - 많은 트래픽으로 인해 패킷 처리 속도가 느려지거나 유실될 우려가 있는 상황
  - Ex) 혼잡제어가 이루어 지지 않는다면? `혼잡붕괴현상`
    - 혼잡 -> 유실 -> 각각의 호스트는 재전송진행 -> 라우터입장에서 과부하상태에서 더 과부하  -> 혼잡 -> 유실 -> 재전송..반복
  - 이러한 혼잡붕괴현상을 방지하기 위해 만들어진게 혼잡제어이다.
  - 혼잡제어는 혼잡이 생기지 않을 정도로만 조금씩 전송하는 방법
  * 흐름제어의 주체는 수신호스트였지만, 혼잡제어의 주체는 송신호스트이다. 송신호스트가 혼잡하지 않은상황을 스스로 판단해서 보내는게 중요하다.

  - 혼잡윈도우 : 혼잡 없이 전송할 수 있을 법한 양
  - 송신호스트 : 최소값(수신윈도우, 혼잡윈도우) >= 마지막으로 송신한 바이트 - 마지막으로 수신 확인된 바이트
    - 혼잡윈도우는 내가 혼잡을 피할수 있을 만한 양과 수신지가 한꺼번에 받을 수 있을 만한 양(수신윈도우)의 최소값을 넘지 않을만큼 전송해야 한다.

  - 기본동작형태 : AIMD(Additive Increase Multicative Decrease)
    
    ![system_network_TCP19.png](/assets/images/system_network_TCP19.png)

       - 선형적으로 증가하다가 혼잡상황을 검출하면 혼잡윈도우 크기를 반으로 뚝 떨어지는것.

  - **RTT(Round Trip Time)**

    ![system_network_TCP20.png](assets/images/system_network_TCP20.png)

      - 메세지를 전송한 뒤 그에 대한 답변을 받는 시간

      ```shell
      $ ping -c 5 www.google.com
      ```
        - rtt min/avg/max/mdev
          - 최소/평균/최대/표준편차 라고 해서 rtt값이 나온다.

  - TCP혼잡제어 알고리즘 : 혼잡제어를 수행하는 알고리즘
    1. 느린시작(slow start)
       
       ![system_network_TCP21.png](/assets/images/system_network_TCP21.png)

        - ACK세그먼트가 수신될 때마다 혼잡 윈도우 1증가(RTT마다 혼잡 윈도우 2배 증가)
        - 초기 전송속도를 빠르게 확보하기 위한 방법
        - 특정임계치(sshresh)값과 같아지면 혼잡회피 수행 

    2. 혼잡회피
      - 매 RTT마다 혼잡 윈도우 1씩 증가
      - 세번의 중복 세그먼트가 발생했을 경우 빠른 회복 수행
        - 3번의 중복 세그먼트 발생시 빠른재전송을 한다.

    3. 빠른회복

      - 3번의 중복 ACK세그먼트가 수신되었을때 느린 시작을 건너뛰고 혼잡 회피를 수행하는 알고리즘

      ![system_network_TCP22.png](/assets/images/system_network_TCP22.png)

        - TCP Tahoe(빠른 회복 미수행) vs TCP Reno(빠른 회복 수행)

    - 혼잡제어 알고리즘

      [참조 : network top down approach, james kurose]

      ![system_network_TCP23.png](/assets/images/system_network_TCP23.png)

        - cwnd : 혼잡윈도우 크기
        - ssthresh : 느린시작임계치
        - dupACKcount : 중복된 ACK횟수 
        
## 5. 응용계층
HTTP와 웹기술

### 5-1. DNS

네트워크 상에서 호스트를 특정 지을 수 있는 주소
  - MAC 주소
  - IP주소 : 언제든 변경가능

DNS란 도메인과 IP주소를 연결시켜주는 프로토콜이며, 전화번호부와 유사한 기능을 수행한다.

사람이 기억하기 쉬운 도메인 이름과 호스트를 특정지을 주소를 매핑하는 기능을 수행한다.

> 도메인 <br>
: 호스트에 부여되는 문자열 이름(ex.google.com)

전화번호부는 2가지 종류가 있다.
1. 개인소유 전화번호부 : 호스트마다 도메인이름과 IP주소를 매핑짓는 정보

  ![system_network_DNS.png](/assets/images/system_network_DNS.png)

    - 각 OS마다 지정되어 있는 경로에 있다.
      - 해당 호스트가 어떤 IP주소를 매핑할지를 개개인별로 정해져 있음.
    
    ```shell
    $ cat /etc/hosts
    ```

모든 전화번호부를 /etc/hosts에 적을수 없다.그래서 보통은 공용전화번호부에 빗댈수 있는 DNS 서버에 이 도메인을 갖고있는 서버의 IP주소는 무엇인지 물어보게 된다.

#### 5-1-1. 계층적 도메인 구조

DNS서버들은 계층적 도메인구조를 띄고있다.

  ![system_network_DNS3.png](/assets/images/system_network_DNS3.png)

  [DNS 루트서버란?](https://www.cloudflare.com/ko-kr/learning/dns/glossary/dns-root-server/)
  
    ![system_network_DNS2.png](/assets/images/system_network_DNS2.png)

[루트네임서버 정의](https://ko.wikipedia.org/wiki/%EB%A3%A8%ED%8A%B8_%EB%84%A4%EC%9E%84_%EC%84%9C%EB%B2%84)



TLD(Top-Level_Domain)

  [인터넷 최상위 도메인 목록](https://ko.wikipedia.org/wiki/%EC%9D%B8%ED%84%B0%EB%84%B7_%EC%B5%9C%EC%83%81%EC%9C%84_%EB%8F%84%EB%A9%94%EC%9D%B8_%EB%AA%A9%EB%A1%9D)

    - 최상위 도메인 관리해주는 DNS서버가 TLD서버이다.

2. 공용전화번호부 : 특정 DNS를 수행해주는 서버를 이용해 주소를 매핑짓는 정보


서브도메인(하위도메인)
  - 도메인의 일부인 도메인
     - ex) naver.com -> **maps**.naver.com
     - ex) wikipedia.com -> **en**.wikipedia.com

각 도메인을 담당하는 도메인 서버
  - ROOT 네임서버
  - TLD서버
  - Authoritative DNS 서버 : 찾고자 하는 도메인의 IP주소를 저장하는 최종 서버
  - local DNS 서버 : 클라이언트가 가장 먼저 찾는 DNS서버 (DNS Resolver)
    - local DNS 서버 주소 명시적 설정 <- Public DNS
      - ex) [ Google public dns서버 ](https://developers.google.com/speed/public-dns?hl=ko)
        - 8.8.8.8 : 내컴퓨터가 모르는 도메인을 처음 치면, 가장먼저 8.8.8.8 IP를 갖고 있는 구글이 제공하고 있는 DNS서버한테 가장 먼저 물어보게 된다.
        - 그럼 이놈이 알아서 계층적인 구조를 갖고있는 DNS서버한테 이 도메인에 해당하는 IP가 뭐야라고 물어보게 되고 결과적으로 Authoritative DNS서버로부터 IP주소를 알아내게 됬다면 8.8.8.8이 내컴퓨터한테 해당하는 IP주소를 알려주게 된다.
         

    - local DNS 서버 주소 자동 설정 <- ISP
      - DHCP프로토콜을 할당받을때 DNS서버도 ISP가 설정한 로컬 DNS서벚 수로ㅗ 알아서 입력이 된다.
       
    - 해당 도메인IP주소를 모른다면, local DNS서버에게 제일먼저 해당 도메인에 해당하는 IP주소가 뭔지 물어본다. 그러면 DNS resolver는 클라이언트를 대신해서 Root name server > TLD 서버 > Authoritative DNS서버를 거치면서 차례대로 물어본다. 그래서 알아냈다면 최종적으로 컴퓨터에게 해당하는 IP주소를 알려주게 된다.
    - 나의 컴퓨터가 가장먼저 찾게 되는 DNS 서버는 DNS resolver라는 local DNS 서버이다.
    - 내 컴퓨터에서 처음으로 어떤 도메인 주소를 입력했다면 해당 도메인에 해당하는 IP주소를 찾아주는 애는 local DNS 서버이다.
    - 그리고 최종적으로 저장하고 있는 애는 Authoritative DNS 서버이다.
    - 도메인서버들은 계층적구조를 띄고있는데 가장 최상단에 위치한 네임서버는 Root 네임서버이다.

반복적 질의

  도메인주소가 IP주소로 변환이 어떻게 되는지 한번더 살펴보기.
  
  ![system_network_DNS4.png](/assets/images/system_network_DNS4.png)

    - [출처 : network top down approach]
    - local DNS server ( = local DNS 서버)
    - requesting host ( = 나의 호스트)

    - 처음 호스트(클라이언트)가 모르는 DNS에 처음 접근시 로컬 DNS 서버에게 물어본다.(이 도메인에 해당하는 IP가 뭐야?)
    - 그러면 local DNS  server는 가장먼저 root DNS 서버에게 묻는다.
    - 그러면 .edu를 관리하고 있는거에 물어보라고 답변한다.
    - .edu를 관리하는 TLD DNS server에게 이제 묻는다.
    - umass.edu를 관리하는 서버는 여기라고 답변한다.
    - 이런식으로 도메인 주소가 더 구체적으로 물어봐지게 된다.
    - 최종적으로 알아내면 그건 Authoritative DNS 서버이고, 거기서 해당 도메인에 대한 IP주소를 얻을수 있다.

재귀적 질의

  ![system_network_DNS5.png](/assets/images/system_network_DNS5.png)

    - local DNS 서버에서 처음 물어보는건 root DNS server이다.
    - 그이후, root가 직접 TLD DNS 서버에게 물어보고 응답받는 형식이 재귀적 질의방식이다.


DNS서버는 무엇을 저장하고 있을까? DNS 레코드(자원레코드)를 저장하고 있다.
  - 어떤 종류의 자원인지를 나타내는게 DNS 레코드의 타입이다.
  - 웹프로그래밍 배포시 DNS서버 설정하게 된다.
  - 레코드 타입, 호스트, IP주소, TTL등을 넣게 된다.

  - A 레코드 : 도메인에 대한 IPv4 주소를 일대일 매핑
  - AAAA 레코드 : 도메인에 대한 IPv6 주소를 일대일 매핑
  - CNAME 레코드 : 도메인에 대한 별칭
    - aws에서 별칭지정하면, 원래 도메인에 접속을 해도 내부적으로 변경되는 도메인을 인지하지 않고서도 같은 도메인에 접속할 수 있게끔 할수 있다.
  - NS 레코드 : 네임 서버 주소
  - SOA 레코드 : 도메인에 대한 관리자 정보

DNS캐시 : TTL기간동안 DNS 저장
  - 일부 자주 접속하는 주소에 대해서는 캐싱할수 있다. 그 캐시된 정보가 얼만큼 남아있을지에 대한 정보가 바로 TTL값이다. 즉, 이 기간 동안 DNS항목을 저장하겠다를 나타내는 정보가 TTL이다.

  ```shell
  > ipconfig /displaydns
  ```
  

### 5-2. URI/URL/URN

자원과 자원의 식별

네트워크 상에서의 `자원`의 의미는?
  - 네트워크로 주고받을 수 있는 모든 정보
    - ex) 파일, 이미지, 동영상, HTML, XML, JSON ...

네트워크 상에서의 자원이 필요하다면 자원을 요청해야 함. 자원을 요청하고 요청한 자원을 응답하려면 자원을 식별(identify)할 수 있어야 한다.(-> 자원의 식별자(identifier)가 있어야 한다.)

자원의 식별자(= URI, Uniform Resource Identifier) : 자원을 식별할 수 있는 문자열
  - URI는 위치 혹은 이름으로 분류가능하다.

    ![system_network_URI.png](/assets/images/system_network_URI.png)
  
      1. **URL ( Uniform Resource Locator)** : 위치 기반 자원 식별 

        - URL 구성요소
          - scheme
            - 일반적으로 프로토콜 이름 명시 : 어떤식으로 데이터를 주고받을지에 대한 방식이 정의된다.
              - ex)
                - ftp://ftp.kernel.org/
                - http://example.com
                - https://www.iana.org/assignments/uri-schemes/uri-schemes.xhtml
                - chrome://chrome-urls/#internal-debug-pages

          - authority = [userinfor"@"]host[":"port]
            - (생략가능) 사용자 이름을 이용한 인증 가능 
            - 호스트이름 : 도메인 이름 혹은 IP주소
            - (생략가능) 포트번호 
              - 443 : https를 의미
              - 80 : http를 의미

          - path 
            - 자원이 위치한 경로
              - ex)
               - https://myblog/posts/50
               - https://www.iana.org/_img/2015.1/iana-logo-header-notext.svg
           
          - query

            - GET요청보낼때 많이 사용한다.
            - key:value 형태로 서버에 전달할 문자 형태의 파라미터
            - ?로 시작을 나타낸다.
            - & (혹은 ;) 로 다수의 query 구분
            - ex) https://www.google.com/search?q=fastcampus&hl-ko
              - google.com에게 fastcampus라는 검색어와 언어는 한국어로 해주세요를 요청하는것과 같다.
              - key : value = query : fastcampus가 된다.

          - fragment
            - 자원의 조각(fragment)를 가리키는 데에 사용 (#로 구분)
            - 북마크 기능에서 많이 사용, 특정위치 바로가기에 사용된다.
            - fragment정보는 서버에 전달되지는 않는다.
            - ex)
              - https://docs.python.org/ko/dev/howto/sockets.html#creating-a-socket
              - https://docs.python.org/ko/dev/howto/sockets.html#ipc

      2. URN ( Uniform Resource Name) : 이름 기반 자원 식별 

URL해석연습
  - https://john.doe@www.example.com:123/forum/questions/?tag=networking&order=newest#top

| 예시 | https://john.doe@www.example.com:123/forum/questions/?tag=networking&order=newest#top |
| scheme | https:// |
| authority : userinfor | john.doe@ |
| authority : host | www.example.com |
| authority : port | 123 |
| path | forum/questions | 
| query | ?tag=networking&order=newest |
| fragment | #top |

| 예시 | telnet://192.0.2.16:80/ |
| 해석 | telnet형태로 데이터를 주고받을것이다. |
| authority : host | 192.0.2.16 |
| authority : port | 80 |


브라우저 창에서 URL, scheme확인가능
  ![system_network_URI2.png](/assets/images/system_network_URI2.png)
    > F12 > network > 마우스 오른쪽클릭시 URL, scheme 등 확인가능
  


---


[맨 위로 이동하기](#){: .btn .btn--primary }{: .align-right}