---
title:  "About FastAPI"
excerpt: " About FastAPI"

categories:
  - Python
tags:
  - [Python]

toc: true
toc_sticky: true

breadcrumbs: true
 
date: 2024-01-02
last_modified_at: 2024-01-02
---



## 1. FastAPI란?
- python web framework
- python 3.6 version 이상에서 적용가능

### 1-1. 특징
- 데이터 타입을 endpoint로 명시하지 않아도 자동으로 바꾸어준다
- Uvicorn ASGI Server를 사용


#### Q) WSGI?

![python_WSGI](/oc-jspark.github.io/assets/images/python_WSGI.png)

- Python Web Server Gateway Interface (WSGI)
- web server와 web application or python기반의 framework 간의 interface
- CGI표준을 기반으로 설계됨.
- WSGI는 파이썬 웹 개발의 핵심 구성 요소이며, 다양한 웹 서버와 애플리케이션 간의 통합을 용이하게 함
  - ex) 개발자가 FASTAPI 같은 프레임워크를 사용하여 애플리케이션 개발한 경우, WSGI를 지원하는 어떤 웹서버와도 해당 애플리케이션을 호스팅할 수 있게 해주는 역할.
- **즉, 웹서버에서의 요청을 해서해 파이썬 애플리케이션 쪽으로 던지는 역할**
- 2가지로 나뉨
  1. server or gateway
  2. application or application framework
- WSGI(동기) 와 ASGI(비동기)방식으로 표현

## 2. Gunicorn?

Gunicorn은 python WSGI이다. <br>
Web Server(Nginx)로부터 요청을 받으면 웹 애플리케이션(Django)로 전달해주는 역할을 수행. <br>
장점 ) WSGI는 multi-thread 만들수 있기 때문에 Request가 많아지더라도 효율적으로 처리 가능.

- 웹 서버와 애플리케이션 사이에서 Request 처리해주는 역할을 하는것이 Gunicorn이다.

#### Q) ASGI?
![python_ASGI](/oc-jspark.github.io/assets/images/python_ASGI.png)
- Asynchronous Server Gateway Interface (ASGI)
- ASGI는 WSGI의 확장버전이며, WSGI의 비동기 버전이다.
- WSGi가 sing-thread 요청 처리에 초점을 맞추었다면, ASGI는 비동기 I/O를 통해 여러 요청을 **동시에** 처리 할 수 있는 구조 제공.
- 비동기 web server
  - async / await 구문 사용
  
  ```
  @app.post('/predict')   
  async def predict(file: UploadFile):
    image_bytes = await file.read()
  ```

#### Q) 비동기방식?
- 비동기방식은 DB나 API연동과정에서 발생하는 대기 시간을 낭비하지 않고, CPU가 다른 작업을 할수 있또록 하는 방식

#### Q) CGI?
- Common Gateway Interface
- client와 web server간의 통신방식을 정의하는 프로그램
- client가 요청을 보내고 web server는 HTTP프로토콜에 따라 요청 내용을 분석한 후 반환된 콘텐츠를 캡슐화 진행.



## 2. Uvicorn?
- 매우 가벼운 ASGI서버
- Uvicorn은 python으로 작성된 ASGI규격을 구현한 비동기 웹서버.
- ASGI 3.0 사양을 완벽하게 구현하며, 이로인해 FastAPI, Django 등 python 웹 프레임워크와 원활하게 호환 가능
- product환경에서도 웹서버로 사용하거나, Nginx와 같은 reverse-proxy 뒤에 배치하여 사용 가능.
- FastAPI framework만으로는 웹개발을 할 수 없고, ASGI와 호환되는 웹서버가 필요.
- 비동기 방식이 가능한 python web server framework(ex.FastAPI)와 application간의 표준 interface를 제공
- 배포에 별도의 준비가 필요없음.


### Reverse Proxy

: 클라이언트 요청을 대신 받아 **내부 서버로 전달** 해주는 것

![python_reverse-proxy](/oc-jspark.github.io/assets/images/python_reverse-proxy.png)

> proxy ? <br>
**대리** 란 의미로, **정보를 대신 전달해주는 주체** 이다. <br>
만약 proxy 없이 웹서버를 운영하게 된다면, localhost:8000 라고 하는 웹서버를 열어서 운영할때, <br>
웹 서버가 그대로 노출되어 있기 때문에 보안적으로 위험함. 

- Nginx를 사용하면 load balancing으로 부하를 줄여줄 수 있고, 분산 처리 또한 가능하며 웹서버의 SSL인증도 적용 가능.

- 따라서 **사용자 -> Nginx -> 웹서버** 로 구성해서 사용자의 요청을 Nginx가 대신 웹서버로 전달해 주도록 구성함.
- 리버스 프록시의 장점
  1. load balancing <br>
    : Nginx는 클라이언트의 요청을 프록시 서버에 분산하기 위해 로드 밸런싱을 수행하여 성능, 확장성 및 신뢰성을 향상시킬 수 있음.
  2. cashing <br>
    : Nginx를 역방향 프록시로 사용하면 미리 렌더링된 버전의 페이지를 캐시하여 페이지 로드 시간 단축가능. 이 기능은 프록시 서버의 응답에서 수신한 콘텐츠를 캐싱하고 이 콘텐츠를 사용하여 매번 동일한 콘텐츠를 프록시 서버에 연결할 필요 없이 클라이언트에 응답하는 방식으로 작동.
  3. SSL 터미네이션 <br>
    : Nginx는 클라이언트와의 연결에 대한 SSL 끝점 역할을 할 수 있음. 수신 SSL 연결을 처리 및 해독하고 프록시 서버의 응답을 암호화 함.
  4. 압축 <br>
    : 프록시 서버가 압축된 응답을 보내지 않는 경우 클라이언트로 보내기 전에 응답을 압축하도록 Nginx 구성 가능.
  5. DDoS 공격 완화 <br>
    : 수신 요청과 단일 IP주소당 연결 수를 일반 사용자에게 일반적인 값으로 제한할 수 있음. 또한 Nginx를 사용하면 클라이언트 위치와 "User-agent" 및 "Referer"와 같은 요청 헤더 값을 기준으로 액세스를 차단하거나 제한할 수 있음.


## 3. 설치 및 코드 구현

### 3-1. FastAPI 및 uvicorn 설치
```
$ pip install fastapi uvicorn
```
: framework 및 web server 생성됨.

### 3-2. main.py
```
from fastapi import FastAPI
app = FastAPI() #인스턴스 생성

@app.get("/") # get method로 '/'에 해당하는  생성
def root():
    return {'Hello':'World!'} 


@app.post('/predict')   
async def predict(file: UploadFile):
    image_bytes = await file.read()
    
    # 분류 결과 확인 및 클라이언트에게 결과 반환
    class_name = get_prediction(image_bytes=image_bytes)
    print("결과:", {'class_name': class_name})
    return JSONResponse({'class_name': class_name})

if __name__ == '__main__':
  uvicorn.run(app, host="0.0.0.0", port=8000)
```

### 3-2-1. 서버생성
- **uvicorn.run(app, host="0.0.0.0", port=8000)** 말고 다른 방법으로 서버생성하는법.
```
$ uvicorn main:app --reload
```
- main : 모듈명을 의미
- app : FastAPI로부터 생성된 인스턴스를 의미 # app = FastAPI()
- reload : 코드 수정시 새로고침을 의미 (Flask의 app.run(debug=True)와 같은 효과)

#### Q) endpoint?
- 특정 서비스의 client들이 접근 할 수 있는 웹주소를 의미



```mermaid

graph TD

  A[사용자_Streamlit (app.py)] .-> |대화입력| B (세션 상태에 메시지 저장)
  B -->|조건부 응답| C[Assistant 메시지 출력]
  C -->|음악 생성 버튼 클릭| D[POST 요청 to FastAPI /generate-music/]

  D --> E[FastAPI (main.py)]
  E --> F[SunoAPIHandler.generate_music()]
  F --> G[Suno API - 음악 생성 요청]
  G --> H[Task ID 반환]
  H --> I[poll_for_music() - 폴링 요청 반복]
  I -->|음악 생성 완료| J[오디오 URL 획득]
  J -->|JSON 응답| K[Streamlit에서 오디오 재생]

```
[맨 위로 이동하기](#){: .btn .btn--primary }{: .align-right}
 

